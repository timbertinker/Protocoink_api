import { providers } from 'ethers';
import { Config, SwapTokenLogicFields, SwapTokenLogicOptions, SwapTokenLogicParams } from './types';
import { Currency, CurrencyAmount, Token, TradeType } from '@uniswap/sdk-core';
import { FeeAmount, Pool, Route } from '@uniswap/v3-sdk';
import * as core from '@protocolink/core';
export interface LogicOptions {
    chainId: number;
    provider?: providers.Provider;
    config: Config;
}
export declare abstract class SwapTokenLogic extends core.Logic {
    readonly config: Config;
    constructor({ chainId, provider, config }: LogicOptions);
    quote(params: SwapTokenLogicParams): Promise<SwapTokenLogicFields>;
    build(fields: SwapTokenLogicFields, options: SwapTokenLogicOptions): Promise<{
        to: string;
        data: string;
        inputs: core.DataType.InputStruct[];
        wrapMode: number;
        approveTo: string;
        callback: string;
    }>;
    getBestTrade(tradeType: TradeType, amountSpecified: CurrencyAmount<Currency>, otherCurrency: Currency): Promise<{
        route: Route<Currency, Currency>;
        inputAmount: CurrencyAmount<Currency>;
        outputAmount: CurrencyAmount<Currency>;
    }>;
    getAllRoutes(currencyIn: Currency, currencyOut: Currency): Promise<Route<Currency, Currency>[]>;
    getPools(currencyIn: Currency, currencyOut: Currency): Promise<Pool[]>;
    getAllCurrencyCombinations(currencyA: Currency, currencyB: Currency): [Token, Token][];
    getAllCurrencyCombinationsWithAllFees(currencyIn: Currency, currencyOut: Currency): [Token, Token, FeeAmount][];
    poolEquals(poolA: Pool, poolB: Pool): boolean;
    computeAllRoutes(currencyIn: Currency, currencyOut: Currency, pools: Pool[], currentPath?: Pool[], allPaths?: Route<Currency, Currency>[], startCurrencyIn?: Currency, maxHops?: number): Route<Currency, Currency>[];
    abstract computePoolAddress({ factoryAddress, tokenA, tokenB, fee, initCodeHashManualOverride, }: {
        factoryAddress: string;
        tokenA: Token;
        tokenB: Token;
        fee: FeeAmount;
        initCodeHashManualOverride?: string;
    }): Promise<string>;
}

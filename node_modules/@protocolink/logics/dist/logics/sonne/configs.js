"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCToken = exports.getContractAddress = exports.cTokenToUnderlyingMap = exports.underlyingToCTokenMap = exports.tokenPairs = exports.underlyingTokens = exports.configMap = exports.supportedChainIds = exports.configs = void 0;
const tslib_1 = require("tslib");
const common = tslib_1.__importStar(require("@protocolink/common"));
const tokens_1 = require("./tokens");
exports.configs = [
    {
        chainId: common.ChainId.optimism,
        contract: {
            Comptroller: '0x60CF091cD3f50420d50fD7f707414d0DF4751C58',
        },
        assets: [
            {
                underlyingToken: tokens_1.optimismTokens.OP,
                cTokens: [tokens_1.optimismTokens.soOP],
            },
            {
                underlyingToken: tokens_1.optimismTokens['USDC.e'],
                cTokens: [tokens_1.optimismTokens['soUSDC.e']],
            },
            {
                underlyingToken: tokens_1.optimismTokens.USDT,
                cTokens: [tokens_1.optimismTokens.soUSDT],
            },
            {
                underlyingToken: tokens_1.optimismTokens.DAI,
                cTokens: [tokens_1.optimismTokens.soDAI],
            },
            {
                underlyingToken: tokens_1.optimismTokens.sUSD,
                cTokens: [tokens_1.optimismTokens.soSUSD],
            },
            {
                underlyingToken: tokens_1.optimismTokens.WETH,
                cTokens: [tokens_1.optimismTokens.soWETH],
            },
            {
                underlyingToken: tokens_1.optimismTokens.SNX,
                cTokens: [tokens_1.optimismTokens.soSNX],
            },
            {
                underlyingToken: tokens_1.optimismTokens.WBTC,
                cTokens: [tokens_1.optimismTokens.soWBTC],
            },
            {
                underlyingToken: tokens_1.optimismTokens.LUSD,
                cTokens: [tokens_1.optimismTokens.soLUSD],
            },
            {
                underlyingToken: tokens_1.optimismTokens.wstETH,
                cTokens: [tokens_1.optimismTokens.sowstETH],
            },
            {
                underlyingToken: tokens_1.optimismTokens.MAI,
                cTokens: [tokens_1.optimismTokens.soMAI],
            },
            {
                underlyingToken: tokens_1.optimismTokens.USDC,
                cTokens: [tokens_1.optimismTokens.soUSDCnative],
            },
        ],
    },
];
_a = exports.configs.reduce((accumulator, config) => {
    accumulator[0].push(config.chainId);
    accumulator[1][config.chainId] = config;
    accumulator[2][config.chainId] = [];
    accumulator[3][config.chainId] = [];
    accumulator[4][config.chainId] = {};
    accumulator[5][config.chainId] = {};
    for (const asset of config.assets) {
        const underlyingToken = asset.underlyingToken;
        const cTokens = asset.cTokens;
        accumulator[2][config.chainId].push(underlyingToken);
        accumulator[3][config.chainId].push({ underlyingToken, cToken: cTokens[0] });
        accumulator[4][config.chainId][underlyingToken.address] = cTokens[0];
        for (const cToken of cTokens) {
            accumulator[5][config.chainId][cToken.address] = underlyingToken;
        }
    }
    return accumulator;
}, [[], {}, [], [], {}, {}]), exports.supportedChainIds = _a[0], exports.configMap = _a[1], exports.underlyingTokens = _a[2], exports.tokenPairs = _a[3], exports.underlyingToCTokenMap = _a[4], exports.cTokenToUnderlyingMap = _a[5];
function getContractAddress(chainId, name) {
    return exports.configMap[chainId].contract[name];
}
exports.getContractAddress = getContractAddress;
function toCToken(chainId, underlyingTokenOrAddress) {
    return exports.underlyingToCTokenMap[chainId][common.Token.getAddress(underlyingTokenOrAddress)];
}
exports.toCToken = toCToken;
//# sourceMappingURL=configs.js.map
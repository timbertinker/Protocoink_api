"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapTokenLogic = void 0;
const tslib_1 = require("tslib");
const http_1 = require("../../utils/http");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const utils_1 = require("../../utils");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
const slippage_1 = require("../../logics/zeroex-v4/slippage");
const configs_1 = require("./configs");
class SwapTokenLogic extends core.Logic {
    async getTokenList() {
        return await (0, utils_1.getUnifiedTokens)(this.chainId);
    }
    getAPIBaseUrl(chainId) {
        switch (chainId) {
            case common.ChainId.mainnet:
                return 'https://api.0x.org/';
            case common.ChainId.optimism:
                return 'https://optimism.api.0x.org/';
            case common.ChainId.polygon:
                return 'https://polygon.api.0x.org/';
            case common.ChainId.base:
                return 'https://base.api.0x.org/';
            case common.ChainId.arbitrum:
                return 'https://arbitrum.api.0x.org/';
            case common.ChainId.avalanche:
                return 'https://avalanche.api.0x.org/';
            default:
                throw new Error('Unsupported chain');
        }
    }
    getAPIHeaders(apiKey) {
        return {
            '0x-api-key': apiKey,
        };
    }
    async quote(params) {
        try {
            const { input, tokenOut, slippage, excludedSources, includedSources, apiKey, takerAddress } = params;
            const slippagePercentage = slippage != null ? (0, slippage_1.slippageToZeroEx)(slippage) : undefined;
            const url = this.getAPIBaseUrl(this.chainId) + `swap/v1/price`;
            const { data: { buyAmount }, } = await http_1.axios.get(url, {
                params: {
                    slippagePercentage,
                    sellToken: input.token.elasticAddress,
                    buyToken: tokenOut.elasticAddress,
                    sellAmount: input.amountWei.toString(),
                    excludedSources: excludedSources === null || excludedSources === void 0 ? void 0 : excludedSources.join(','),
                    includedSources: includedSources === null || includedSources === void 0 ? void 0 : includedSources.join(','),
                    takerAddress,
                },
                headers: this.getAPIHeaders(apiKey),
            });
            return {
                input,
                output: new common.TokenAmount(params.tokenOut).setWei(buyAmount),
                slippage,
                excludedSources,
                includedSources,
                apiKey,
            };
        }
        catch (e) {
            (0, tiny_invariant_1.default)(false, 'no route found or price impact too high');
        }
    }
    async build(fields, { account }) {
        const { input, output, slippage, excludedSources, includedSources, apiKey } = fields;
        const slippagePercentage = slippage != null ? (0, slippage_1.slippageToZeroEx)(slippage) : undefined;
        const takerAddress = account;
        const url = this.getAPIBaseUrl(this.chainId) + `swap/v1/quote`;
        const { data: { buyAmount, data, to, allowanceTarget: approveTo }, } = await http_1.axios.get(url, {
            params: {
                slippagePercentage,
                sellToken: input.token.elasticAddress,
                buyToken: output.token.elasticAddress,
                sellAmount: input.amountWei.toString(),
                excludedSources: excludedSources === null || excludedSources === void 0 ? void 0 : excludedSources.join(','),
                includedSources: includedSources === null || includedSources === void 0 ? void 0 : includedSources.join(','),
                takerAddress,
                skipValidation: true,
            },
            headers: this.getAPIHeaders(apiKey),
        });
        output.setWei(buyAmount);
        const inputs = [core.newLogicInput({ input })];
        return core.newLogic({ to, data, inputs, approveTo });
    }
}
exports.SwapTokenLogic = SwapTokenLogic;
SwapTokenLogic.id = 'swap-token';
SwapTokenLogic.protocolId = 'zeroex-v4';
SwapTokenLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.swap-token.js.map
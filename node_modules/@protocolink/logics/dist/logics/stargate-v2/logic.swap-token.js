"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapTokenLogic = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const contracts_1 = require("./contracts");
const configs_1 = require("./configs");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
class SwapTokenLogic extends core.Logic {
    async getTokenList() {
        const tokenList = [];
        const srcTokens = [];
        const markets = (0, configs_1.getMarkets)(this.chainId);
        for (const market of markets) {
            srcTokens.push(market.token);
        }
        // find destination tokens
        for (const srcToken of srcTokens) {
            const destTokens = [];
            const destChainIds = (0, configs_1.getDestChainIds)(this.chainId, srcToken);
            for (const destChainId of destChainIds) {
                const destToken = (0, configs_1.getDestToken)(srcToken, destChainId);
                destTokens.push(destToken);
            }
            tokenList.push({ srcToken, destTokens });
        }
        return tokenList;
    }
    async quote(params) {
        const { input, tokenOut, receiver, slippage } = params;
        const pool = (0, configs_1.getPoolConfigByTokenAddress)(input.token.chainId, input.token.address);
        let output = new common.TokenAmount(tokenOut);
        let fee = ethers_1.BigNumber.from('0');
        let oftFee = ethers_1.BigNumber.from('0');
        if (pool.id === configs_1.PoolId.OFT) {
            const oftWrapper = contracts_1.OFTWrapper__factory.connect(pool.address, this.provider);
            const oft = pool.proxyOFT ? pool.proxyOFT : input.token.address;
            const destChainId = (0, configs_1.getStargateChainId)(tokenOut.chainId);
            const srcAmount = input.amountWei;
            const adapterParameters = ethers_1.utils.solidityPack(['uint16', 'uint256'], [1, 200000]);
            const feeObj = {
                callerBps: 0,
                caller: ethers_1.constants.AddressZero,
                partnerId: ethers_1.utils.hexZeroPad(ethers_1.utils.solidityPack(['bytes'], [0]), 2),
            };
            [fee] = await oftWrapper.estimateSendFeeV2(oft, destChainId, ethers_1.utils.hexZeroPad(ethers_1.utils.solidityPack(['address'], [receiver]), 32), input.amountWei, false, adapterParameters, feeObj);
            fee = common.calcSlippage(fee, -1); // slightly higher than the quoted fee
            oftFee = await contracts_1.OFTV2__factory.connect(oft, this.provider).quoteOFTFee(destChainId, srcAmount);
            const [amount] = await oftWrapper.getAmountAndFees(oft, srcAmount, feeObj.callerBps);
            output = output.setWei(amount);
        }
        return {
            input,
            output,
            fee: common.toBigUnit(fee, common.getNativeToken(this.chainId).decimals),
            oftFee: common.toBigUnit(oftFee, input.token.decimals),
            receiver,
            slippage,
        };
        //   } else {
        //   // check if tokenOut is legit
        //   const destToken = getDestToken(input.token, tokenOut.chainId);
        //   if (!tokenOut.is(destToken)) {
        //     return {
        //       input,
        //       output: new common.TokenAmount(tokenOut),
        //       fee: '0',
        //       lzTokenFee: '0',
        //       receiver,
        //     };
        //   }
        //   const dstEid = getEndpointId(tokenOut.chainId);
        //   const to = utils.hexZeroPad(utils.solidityPack(['address'], [receiver]), 32);
        //   const poolAddress = getPoolByTokenAddress(this.chainId, input.token.address);
        //   const amountLD = input.amountWei;
        //   const sendParam = {
        //     dstEid,
        //     to,
        //     amountLD,
        //     minAmountLD: amountLD,
        //     extraOptions: utils.solidityPack(['string'], ['']),
        //     composeMsg: utils.solidityPack(['string'], ['']),
        //     oftCmd: utils.solidityPack(['string'], ['']),
        //   };
        //   const stargate = StargatePool__factory.connect(poolAddress, this.provider);
        //   const [, , receipt] = await stargate.quoteOFT(sendParam);
        //   sendParam.minAmountLD = receipt.amountReceivedLD;
        //   const messagingFee = await stargate.quoteSend(sendParam, false);
        //   const fee = common.toBigUnit(messagingFee.nativeFee, getNativeToken(this.chainId).decimals),
        //   const lzTokenFee = common.toBigUnit(messagingFee.lzTokenFee, getNativeToken(this.chainId).decimals);
        //   const output = new common.TokenAmount(tokenOut).setWei(receipt.amountReceivedLD);
        // }
    }
    async build(fields, options) {
        const { input, output, fee, oftFee, /*lzTokenFee,*/ receiver, balanceBps, slippage } = fields;
        const { account } = options;
        const refundAddress = account;
        const pool = (0, configs_1.getPoolConfigByTokenAddress)(input.token.chainId, input.token.address);
        const to = pool.address;
        const destChainId = (0, configs_1.getStargateChainId)(output.token.chainId);
        const receiverBytes32 = ethers_1.utils.hexZeroPad(ethers_1.utils.solidityPack(['address'], [receiver]), 32);
        const amount = input.amountWei;
        const minAmount = slippage ? common.calcSlippage(output.amountWei, slippage) : output.amountWei;
        const adapterParams = ethers_1.utils.solidityPack(['uint16', 'uint256'], [1, 200000]);
        const lzCallParams = {
            refundAddress,
            zroPaymentAddress: ethers_1.constants.AddressZero,
            adapterParams,
        };
        const feeObj = {
            callerBps: 0,
            caller: ethers_1.constants.AddressZero,
            partnerId: ethers_1.utils.hexZeroPad(ethers_1.utils.solidityPack(['bytes'], [0]), 2),
        };
        const amountOffset = balanceBps ? common.getParamOffset(3) : undefined;
        let data = '';
        if (pool.proxyOFT) {
            data = contracts_1.OFTWrapper__factory.createInterface().encodeFunctionData('sendProxyOFTFeeV2', [
                pool.proxyOFT,
                destChainId,
                receiverBytes32,
                amount,
                minAmount,
                lzCallParams,
                feeObj,
            ]);
        }
        else if (pool.id == configs_1.PoolId.OFT) {
            data = contracts_1.OFTWrapper__factory.createInterface().encodeFunctionData('sendOFTFeeV2', [
                input.token.address,
                destChainId,
                receiverBytes32,
                amount,
                minAmount,
                lzCallParams,
                feeObj,
            ]);
        }
        //  else {
        // const dstEid = getEndpointId(output.token.chainId);
        // const amountLD = input.amountWei;
        // const minAmountLD = output.amountWei;
        // const sendParam = {
        //   dstEid,
        //   to: utils.hexZeroPad(utils.solidityPack(['address'], [receiver]), 32),
        //   amountLD,
        //   minAmountLD,
        //   extraOptions: utils.solidityPack(['string'], ['']),
        //   composeMsg: utils.solidityPack(['string'], ['']),
        //   oftCmd: utils.solidityPack(['string'], ['']),
        // };
        // const nativeToken = getNativeToken(this.chainId);
        // const messagingFee = {
        //   nativeFee: new common.TokenAmount(nativeToken, fee).amountWei,
        //   lzTokenFee: new common.TokenAmount(nativeToken, lzTokenFee).amountWei,
        // };
        // const data = StargatePool__factory.createInterface().encodeFunctionData('sendToken', [
        //   sendParam,
        //   messagingFee,
        //   refundAddress,
        // ]);
        // does not support unwrapBefore so users need to unwrap wrapped native token first
        // }
        // const amountOffset = balanceBps ? common.getParamOffset(2) : undefined;
        const inputs = [
            core.newLogicInput({
                input: new common.TokenAmount(input.token, input.clone().add(oftFee).amount),
                balanceBps,
                amountOffset,
            }),
            core.newLogicInput({ input: new common.TokenAmount(common.getNativeToken(this.chainId), fee) }),
        ];
        const wrapMode = core.WrapMode.none;
        return core.newLogic({ to, data, inputs, wrapMode });
    }
}
exports.SwapTokenLogic = SwapTokenLogic;
SwapTokenLogic.id = 'swap-token';
SwapTokenLogic.protocolId = 'stargate-v2';
SwapTokenLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.swap-token.js.map
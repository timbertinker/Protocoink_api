"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const types_1 = require("./types");
const common = tslib_1.__importStar(require("@protocolink/common"));
const ethers_1 = require("ethers");
const configs_1 = require("./configs");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
class Service extends common.Web3Toolkit {
    get protocolDataProvider() {
        if (!this._protocolDataProvider) {
            this._protocolDataProvider = contracts_1.ProtocolDataProvider__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'ProtocolDataProvider'), this.provider);
        }
        return this._protocolDataProvider;
    }
    get protocolDataProviderIface() {
        if (!this._protocolDataProviderIface) {
            this._protocolDataProviderIface = contracts_1.ProtocolDataProvider__factory.createInterface();
        }
        return this._protocolDataProviderIface;
    }
    get lendingPoolIface() {
        if (!this._lendingPoolIface) {
            this._lendingPoolIface = contracts_1.LendingPool__factory.createInterface();
        }
        return this._lendingPoolIface;
    }
    async getLendingPoolAddress() {
        if (!this.lendingPoolAddress) {
            const addressProviderAddress = await this.protocolDataProvider.ADDRESSES_PROVIDER();
            this.lendingPoolAddress = await contracts_1.LendingPoolAddressesProvider__factory.connect(addressProviderAddress, this.provider).getLendingPool();
        }
        return this.lendingPoolAddress;
    }
    async getReserveTokens() {
        if (!this.reserveTokens || !this.reserveMap) {
            const tokenAddresses = [];
            const reserveTokens = [];
            const reserveMap = {};
            const lendingPoolAddress = await this.getLendingPoolAddress();
            const assetAddresses = await contracts_1.LendingPool__factory.connect(lendingPoolAddress, this.provider).getReservesList();
            const calls = assetAddresses.flatMap((assetAddress) => [
                {
                    target: this.protocolDataProvider.address,
                    callData: this.protocolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
                },
                {
                    target: this.protocolDataProvider.address,
                    callData: this.protocolDataProviderIface.encodeFunctionData('getReserveTokensAddresses', [assetAddress]),
                },
            ]);
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            assetAddresses.forEach((assetAddress, i) => {
                const { isActive, isFrozen, borrowingEnabled } = this.protocolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[i * 2]);
                const { rTokenAddress, stableDebtTokenAddress, variableDebtTokenAddress } = this.protocolDataProviderIface.decodeFunctionResult('getReserveTokensAddresses', returnData[i * 2 + 1]);
                reserveMap[assetAddress] = {
                    isSupplyEnabled: isActive && !isFrozen,
                    isBorrowEnabled: isActive && !isFrozen && borrowingEnabled,
                };
                tokenAddresses.push(assetAddress, rTokenAddress, stableDebtTokenAddress, variableDebtTokenAddress);
            });
            const tokens = await this.getTokens(tokenAddresses);
            for (let i = 0; i < tokens.length; i += 4) {
                const asset = tokens[i];
                const rToken = tokens[i + 1];
                const stableDebtToken = tokens[i + 2];
                const variableDebtToken = tokens[i + 3];
                const reserveToken = {
                    ...reserveMap[asset.address],
                    asset,
                    rToken,
                    stableDebtToken,
                    variableDebtToken,
                };
                reserveTokens.push(reserveToken);
                reserveMap[asset.address] = reserveToken;
                // Add rToken address as key for quick lookup
                reserveMap[rToken.address] = reserveToken;
            }
            this.reserveTokens = reserveTokens;
            this.reserveMap = reserveMap;
        }
        return { reserveTokens: this.reserveTokens, reserveMap: this.reserveMap };
    }
    async getAssets() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.map(({ asset }) => asset);
    }
    async getATokens() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.map(({ rToken }) => rToken);
    }
    async getSupplyTokens() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.filter(({ isSupplyEnabled }) => isSupplyEnabled);
    }
    async getBorrowTokens() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.filter(({ isBorrowEnabled }) => isBorrowEnabled);
    }
    async toRToken(asset) {
        var _a;
        const { reserveMap } = await this.getReserveTokens();
        const rToken = (_a = reserveMap[asset.wrapped.address]) === null || _a === void 0 ? void 0 : _a.rToken;
        (0, tiny_invariant_1.default)((rToken === null || rToken === void 0 ? void 0 : rToken.address) !== ethers_1.constants.AddressZero, `unsupported asset: ${asset.wrapped.address}`);
        return rToken;
    }
    async toRTokens(assets) {
        const { reserveMap } = await this.getReserveTokens();
        return assets.map((asset) => {
            var _a;
            const rToken = (_a = reserveMap[asset.wrapped.address]) === null || _a === void 0 ? void 0 : _a.rToken;
            (0, tiny_invariant_1.default)((rToken === null || rToken === void 0 ? void 0 : rToken.address) !== ethers_1.constants.AddressZero, `unsupported asset: ${asset.wrapped.address}`);
            return rToken;
        });
    }
    async toAsset(rToken) {
        var _a;
        const { reserveMap } = await this.getReserveTokens();
        const asset = (_a = reserveMap[rToken.address]) === null || _a === void 0 ? void 0 : _a.asset;
        (0, tiny_invariant_1.default)(asset, `unsupported aToken: ${rToken.address}`);
        return asset;
    }
    async getDebtTokenAddress(asset, interestRateMode) {
        const { reserveMap } = await this.getReserveTokens();
        const { stableDebtToken, variableDebtToken } = reserveMap[asset.wrapped.address];
        (0, tiny_invariant_1.default)(stableDebtToken || variableDebtToken, `unsupported aToken: ${asset.wrapped.address}`);
        return interestRateMode === types_1.InterestRateMode.variable ? variableDebtToken.address : stableDebtToken.address;
    }
    async getFlashLoanPremiumTotal() {
        const lendingPoolAddress = await this.getLendingPoolAddress();
        const premium = await contracts_1.LendingPool__factory.connect(lendingPoolAddress, this.provider).FLASHLOAN_PREMIUM_TOTAL();
        return premium.toNumber();
    }
    async isDelegationApproved(account, delegateeAddress, assetAmount, interestRateMode) {
        const debtTokenAddress = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const borrowAllowance = await contracts_1.DebtTokenBase__factory.connect(debtTokenAddress, this.provider).borrowAllowance(account, delegateeAddress);
        return borrowAllowance.gte(assetAmount.amountWei);
    }
    async buildApproveDelegationTransactionRequest(delegateeAddress, assetAmount, interestRateMode) {
        const to = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const iface = contracts_1.DebtTokenBase__factory.createInterface();
        const data = iface.encodeFunctionData('approveDelegation', [delegateeAddress, ethers_1.constants.MaxUint256]);
        return { to, data };
    }
    async getFlashLoanConfiguration(assets) {
        const rTokens = await this.toRTokens(assets);
        const poolAddress = await this.getLendingPoolAddress();
        const calls = [
            { target: poolAddress, callData: this.lendingPoolIface.encodeFunctionData('FLASHLOAN_PREMIUM_TOTAL') },
        ];
        for (let i = 0; i < assets.length; i++) {
            const assetAddress = assets[i].wrapped.address;
            calls.push({
                target: this.protocolDataProvider.address,
                callData: this.protocolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
            });
            calls.push({
                target: assetAddress,
                callData: this.erc20Iface.encodeFunctionData('balanceOf', [rTokens[i].address]),
            });
        }
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        let j = 0;
        const [premium] = this.lendingPoolIface.decodeFunctionResult('FLASHLOAN_PREMIUM_TOTAL', returnData[j]);
        const feeBps = premium.toNumber();
        j++;
        const assetInfos = [];
        for (let i = 0; i < assets.length; i++) {
            const { isActive } = this.protocolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[j]);
            j++;
            const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[j]);
            const availableToBorrow = new common.TokenAmount(assets[i]).setWei(balance);
            j++;
            assetInfos.push({ isActive, availableToBorrow });
        }
        return { feeBps: feeBps, assetInfos };
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCToken = exports.getContractAddress = exports.cTokenToUnderlyingMap = exports.underlyingToCTokenMap = exports.tokenPairs = exports.underlyingTokens = exports.COMP = exports.supportedChainIds = exports.config = void 0;
const tslib_1 = require("tslib");
const common = tslib_1.__importStar(require("@protocolink/common"));
const tokens_1 = require("./tokens");
exports.config = {
    chainId: common.ChainId.mainnet,
    contract: {
        Comptroller: '0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B',
        CompoundLens: '0xdCbDb7306c6Ff46f77B349188dC18cEd9DF30299',
    },
    COMP: tokens_1.mainnetTokens.COMP,
    assets: [
        {
            underlyingToken: tokens_1.mainnetTokens.AAVE,
            cTokens: [tokens_1.mainnetTokens.cAAVE],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.BAT,
            cTokens: [tokens_1.mainnetTokens.cBAT],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.COMP,
            cTokens: [tokens_1.mainnetTokens.cCOMP],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.DAI,
            cTokens: [tokens_1.mainnetTokens.cDAI],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.ETH,
            cTokens: [tokens_1.mainnetTokens.cETH],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.FEI,
            cTokens: [tokens_1.mainnetTokens.cFEI],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.LINK,
            cTokens: [tokens_1.mainnetTokens.cLINK],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.MKR,
            cTokens: [tokens_1.mainnetTokens.cMKR],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.SUSHI,
            cTokens: [tokens_1.mainnetTokens.cSUSHI],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.TUSD,
            cTokens: [tokens_1.mainnetTokens.cTUSD],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.UNI,
            cTokens: [tokens_1.mainnetTokens.cUNI],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.USDC,
            cTokens: [tokens_1.mainnetTokens.cUSDC],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.USDP,
            cTokens: [tokens_1.mainnetTokens.cUSDP],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.USDT,
            cTokens: [tokens_1.mainnetTokens.cUSDT],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.WBTC,
            cTokens: [tokens_1.mainnetTokens.cWBTC2, tokens_1.mainnetTokens.cWBTC],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.YFI,
            cTokens: [tokens_1.mainnetTokens.cYFI],
        },
        {
            underlyingToken: tokens_1.mainnetTokens.ZRX,
            cTokens: [tokens_1.mainnetTokens.cZRX],
        },
    ],
};
exports.supportedChainIds = [exports.config.chainId];
exports.COMP = exports.config.COMP;
_a = exports.config.assets.reduce((accumulator, { underlyingToken, cTokens }) => {
    accumulator[0].push(underlyingToken);
    accumulator[1].push({ underlyingToken, cToken: cTokens[0] });
    accumulator[2][underlyingToken.address] = cTokens[0];
    for (const cToken of cTokens) {
        accumulator[3][cToken.address] = underlyingToken;
    }
    return accumulator;
}, [
    [],
    [],
    {},
    {},
]), exports.underlyingTokens = _a[0], exports.tokenPairs = _a[1], exports.underlyingToCTokenMap = _a[2], exports.cTokenToUnderlyingMap = _a[3];
function getContractAddress(name) {
    return exports.config.contract[name];
}
exports.getContractAddress = getContractAddress;
function toCToken(underlyingTokenOrAddress) {
    return exports.underlyingToCTokenMap[common.Token.getAddress(underlyingTokenOrAddress)];
}
exports.toCToken = toCToken;
//# sourceMappingURL=configs.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapTokenLogic = void 0;
const tslib_1 = require("tslib");
const v3_sdk_1 = require("@uniswap/v3-sdk");
const common = tslib_1.__importStar(require("@protocolink/common"));
const configs_1 = require("./configs");
const univ3 = tslib_1.__importStar(require("../../modules/univ3"));
class SwapTokenLogic extends univ3.SwapTokenLogic {
    constructor(chainId, provider) {
        super({ chainId, provider, config: (0, configs_1.getConfig)(chainId) });
    }
    async getTokenList() {
        const response = await fetch('https://gateway.ipfs.io/ipns/tokens.uniswap.org', { method: 'GET' });
        const data = await response.json();
        const tmp = { [this.nativeToken.address]: true };
        const tokenList = [this.nativeToken];
        for (const { chainId, address, decimals, symbol, name, logoURI } of data.tokens) {
            if (tmp[address] || chainId !== this.chainId)
                continue;
            tokenList.push(new common.Token(chainId, address, decimals, symbol, name, logoURI));
            tmp[address] = true;
        }
        return tokenList;
    }
    async computePoolAddress({ factoryAddress, tokenA, tokenB, fee, initCodeHashManualOverride, }) {
        return (0, v3_sdk_1.computePoolAddress)({ factoryAddress, tokenA, tokenB, fee, initCodeHashManualOverride });
    }
}
exports.SwapTokenLogic = SwapTokenLogic;
SwapTokenLogic.id = 'swap-token';
SwapTokenLogic.protocolId = 'uniswap-v3';
SwapTokenLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.swap-token.js.map
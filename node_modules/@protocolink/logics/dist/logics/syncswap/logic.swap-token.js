"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapTokenLogic = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const contracts_1 = require("./contracts");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const utils_1 = require("./utils");
const configs_1 = require("./configs");
class SwapTokenLogic extends core.Logic {
    async getTokenList() {
        return (0, configs_1.getConfig)(this.chainId).tokens;
    }
    // https://jet-uncle-e97.notion.site/SyncSwap-Routing-Resource-db736e425b5240cc8e257c3f313e20b9
    async quote(params) {
        const { input, tokenOut } = params;
        const tokenInAddress = input.token.wrapped.address;
        const tokenOutAddress = tokenOut.wrapped.address;
        const config = (0, configs_1.getConfig)(this.chainId);
        const routeHelper = contracts_1.RouteHelper__factory.connect(config.contract.RouteHelper, this.provider);
        const routePools = await routeHelper.getRoutePools(tokenInAddress, tokenOutAddress, [config.contract.ClassicPoolFactory, config.contract.StablePoolFactory], config.baseTokenAddresses, config.contract.PoolMaster, ethers_1.constants.AddressZero);
        const paths = (0, utils_1.findAllPossiblePaths)(tokenInAddress, tokenOutAddress, (0, utils_1.normalizeRoutePools)(routePools), config.baseTokenAddresses);
        const bestAmount = await (0, utils_1.findBestAmountFromPaths)(this.chainId, paths, input.amountWei);
        const output = new common.TokenAmount(tokenOut).setWei(bestAmount.amountOut);
        return { input, output, paths: bestAmount.paths };
    }
    // https://syncswap.gitbook.io/api-documentation/guides/request-swap-with-router/swap-eth-for-dai
    async build(fields, options) {
        const { input, output, slippage, paths } = fields;
        const { account } = options;
        const agent = await this.calcAgent(account);
        const swapPaths = (0, utils_1.toSwapPaths)(paths, agent);
        const amountOutMin = slippage ? common.calcSlippage(output.amountWei, slippage) : output.amountWei;
        const deadline = ethers_1.BigNumber.from(Math.floor(Date.now() / 1000)).add(1800); // 30m
        const data = contracts_1.Router__factory.createInterface().encodeFunctionData('swap', [swapPaths, amountOutMin, deadline]);
        const inputs = [core.newLogicInput({ input: new common.TokenAmount(input.token.wrapped, input.amount) })];
        const wrapMode = input.token.isNative
            ? core.WrapMode.wrapBefore
            : output.token.isNative
                ? core.WrapMode.unwrapAfter
                : core.WrapMode.none;
        return core.newLogic({ to: (0, configs_1.getContractAddress)(this.chainId, 'Router'), data, inputs, wrapMode });
    }
}
exports.SwapTokenLogic = SwapTokenLogic;
SwapTokenLogic.id = 'swap-token';
SwapTokenLogic.protocolId = 'syncswap';
SwapTokenLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.swap-token.js.map
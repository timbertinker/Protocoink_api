import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from 'ethers';
import type { FunctionFragment, Result } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';
export declare namespace SyncSwapRouter {
    type TokenInputStruct = {
        token: string;
        amount: BigNumberish;
    };
    type TokenInputStructOutput = [string, BigNumber] & {
        token: string;
        amount: BigNumber;
    };
}
export declare namespace IRouter {
    type SplitPermitParamsStruct = {
        token: string;
        approveAmount: BigNumberish;
        deadline: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
    };
    type SplitPermitParamsStructOutput = [string, BigNumber, BigNumber, number, string, string] & {
        token: string;
        approveAmount: BigNumber;
        deadline: BigNumber;
        v: number;
        r: string;
        s: string;
    };
    type ArrayPermitParamsStruct = {
        approveAmount: BigNumberish;
        deadline: BigNumberish;
        signature: BytesLike;
    };
    type ArrayPermitParamsStructOutput = [BigNumber, BigNumber, string] & {
        approveAmount: BigNumber;
        deadline: BigNumber;
        signature: string;
    };
    type SwapStepStruct = {
        pool: string;
        data: BytesLike;
        callback: string;
        callbackData: BytesLike;
    };
    type SwapStepStructOutput = [string, string, string, string] & {
        pool: string;
        data: string;
        callback: string;
        callbackData: string;
    };
    type SwapPathStruct = {
        steps: IRouter.SwapStepStruct[];
        tokenIn: string;
        amountIn: BigNumberish;
    };
    type SwapPathStructOutput = [IRouter.SwapStepStructOutput[], string, BigNumber] & {
        steps: IRouter.SwapStepStructOutput[];
        tokenIn: string;
        amountIn: BigNumber;
    };
}
export declare namespace IPool {
    type TokenAmountStruct = {
        token: string;
        amount: BigNumberish;
    };
    type TokenAmountStructOutput = [string, BigNumber] & {
        token: string;
        amount: BigNumber;
    };
}
export interface RouterInterface extends utils.Interface {
    functions: {
        'addLiquidity(address,(address,uint256)[],bytes,uint256,address,bytes)': FunctionFragment;
        'addLiquidity2(address,(address,uint256)[],bytes,uint256,address,bytes)': FunctionFragment;
        'addLiquidityWithPermit(address,(address,uint256)[],bytes,uint256,address,bytes,(address,uint256,uint256,uint8,bytes32,bytes32)[])': FunctionFragment;
        'addLiquidityWithPermit2(address,(address,uint256)[],bytes,uint256,address,bytes,(address,uint256,uint256,uint8,bytes32,bytes32)[])': FunctionFragment;
        'burnLiquidity(address,uint256,bytes,uint256[],address,bytes)': FunctionFragment;
        'burnLiquiditySingle(address,uint256,bytes,uint256,address,bytes)': FunctionFragment;
        'burnLiquiditySingleWithPermit(address,uint256,bytes,uint256,address,bytes,(uint256,uint256,bytes))': FunctionFragment;
        'burnLiquidityWithPermit(address,uint256,bytes,uint256[],address,bytes,(uint256,uint256,bytes))': FunctionFragment;
        'createPool(address,bytes)': FunctionFragment;
        'enteredPools(address,uint256)': FunctionFragment;
        'enteredPoolsLength(address)': FunctionFragment;
        'isPoolEntered(address,address)': FunctionFragment;
        'multicall(bytes[])': FunctionFragment;
        'selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
        'selfPermit2(address,uint256,uint256,bytes)': FunctionFragment;
        'selfPermit2IfNecessary(address,uint256,uint256,bytes)': FunctionFragment;
        'selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
        'selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
        'selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
        'stake(address,address,uint256,address)': FunctionFragment;
        'swap(((address,bytes,address,bytes)[],address,uint256)[],uint256,uint256)': FunctionFragment;
        'swapWithPermit(((address,bytes,address,bytes)[],address,uint256)[],uint256,uint256,(address,uint256,uint256,uint8,bytes32,bytes32))': FunctionFragment;
        'vault()': FunctionFragment;
        'wETH()': FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: 'addLiquidity' | 'addLiquidity2' | 'addLiquidityWithPermit' | 'addLiquidityWithPermit2' | 'burnLiquidity' | 'burnLiquiditySingle' | 'burnLiquiditySingleWithPermit' | 'burnLiquidityWithPermit' | 'createPool' | 'enteredPools' | 'enteredPoolsLength' | 'isPoolEntered' | 'multicall' | 'selfPermit' | 'selfPermit2' | 'selfPermit2IfNecessary' | 'selfPermitAllowed' | 'selfPermitAllowedIfNecessary' | 'selfPermitIfNecessary' | 'stake' | 'swap' | 'swapWithPermit' | 'vault' | 'wETH'): FunctionFragment;
    encodeFunctionData(functionFragment: 'addLiquidity', values: [string, SyncSwapRouter.TokenInputStruct[], BytesLike, BigNumberish, string, BytesLike]): string;
    encodeFunctionData(functionFragment: 'addLiquidity2', values: [string, SyncSwapRouter.TokenInputStruct[], BytesLike, BigNumberish, string, BytesLike]): string;
    encodeFunctionData(functionFragment: 'addLiquidityWithPermit', values: [
        string,
        SyncSwapRouter.TokenInputStruct[],
        BytesLike,
        BigNumberish,
        string,
        BytesLike,
        IRouter.SplitPermitParamsStruct[]
    ]): string;
    encodeFunctionData(functionFragment: 'addLiquidityWithPermit2', values: [
        string,
        SyncSwapRouter.TokenInputStruct[],
        BytesLike,
        BigNumberish,
        string,
        BytesLike,
        IRouter.SplitPermitParamsStruct[]
    ]): string;
    encodeFunctionData(functionFragment: 'burnLiquidity', values: [string, BigNumberish, BytesLike, BigNumberish[], string, BytesLike]): string;
    encodeFunctionData(functionFragment: 'burnLiquiditySingle', values: [string, BigNumberish, BytesLike, BigNumberish, string, BytesLike]): string;
    encodeFunctionData(functionFragment: 'burnLiquiditySingleWithPermit', values: [string, BigNumberish, BytesLike, BigNumberish, string, BytesLike, IRouter.ArrayPermitParamsStruct]): string;
    encodeFunctionData(functionFragment: 'burnLiquidityWithPermit', values: [string, BigNumberish, BytesLike, BigNumberish[], string, BytesLike, IRouter.ArrayPermitParamsStruct]): string;
    encodeFunctionData(functionFragment: 'createPool', values: [string, BytesLike]): string;
    encodeFunctionData(functionFragment: 'enteredPools', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'enteredPoolsLength', values: [string]): string;
    encodeFunctionData(functionFragment: 'isPoolEntered', values: [string, string]): string;
    encodeFunctionData(functionFragment: 'multicall', values: [BytesLike[]]): string;
    encodeFunctionData(functionFragment: 'selfPermit', values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: 'selfPermit2', values: [string, BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: 'selfPermit2IfNecessary', values: [string, BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: 'selfPermitAllowed', values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: 'selfPermitAllowedIfNecessary', values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: 'selfPermitIfNecessary', values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: 'stake', values: [string, string, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'swap', values: [IRouter.SwapPathStruct[], BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'swapWithPermit', values: [IRouter.SwapPathStruct[], BigNumberish, BigNumberish, IRouter.SplitPermitParamsStruct]): string;
    encodeFunctionData(functionFragment: 'vault', values?: undefined): string;
    encodeFunctionData(functionFragment: 'wETH', values?: undefined): string;
    decodeFunctionResult(functionFragment: 'addLiquidity', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'addLiquidity2', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'addLiquidityWithPermit', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'addLiquidityWithPermit2', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'burnLiquidity', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'burnLiquiditySingle', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'burnLiquiditySingleWithPermit', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'burnLiquidityWithPermit', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'createPool', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'enteredPools', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'enteredPoolsLength', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'isPoolEntered', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'multicall', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'selfPermit', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'selfPermit2', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'selfPermit2IfNecessary', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'selfPermitAllowed', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'selfPermitAllowedIfNecessary', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'selfPermitIfNecessary', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'stake', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'swap', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'swapWithPermit', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'vault', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'wETH', data: BytesLike): Result;
    events: {};
}
export interface Router extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: RouterInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        addLiquidity(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        addLiquidity2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        addLiquidityWithPermit(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        addLiquidityWithPermit2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        burnLiquidity(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        burnLiquiditySingle(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        burnLiquiditySingleWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        burnLiquidityWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        createPool(_factory: string, data: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[boolean]>;
        multicall(data: BytesLike[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        selfPermit(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        selfPermit2(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        selfPermit2IfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        selfPermitAllowed(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        selfPermitAllowedIfNecessary(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        selfPermitIfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        stake(stakingPool: string, token: string, amount: BigNumberish, onBehalf: string, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        swap(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        swapWithPermit(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, permit: IRouter.SplitPermitParamsStruct, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        vault(overrides?: CallOverrides): Promise<[string]>;
        wETH(overrides?: CallOverrides): Promise<[string]>;
    };
    addLiquidity(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    addLiquidity2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    addLiquidityWithPermit(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    addLiquidityWithPermit2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    burnLiquidity(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    burnLiquiditySingle(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    burnLiquiditySingleWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    burnLiquidityWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    createPool(_factory: string, data: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;
    enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<BigNumber>;
    isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;
    multicall(data: BytesLike[], overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    selfPermit(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    selfPermit2(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    selfPermit2IfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    selfPermitAllowed(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    selfPermitAllowedIfNecessary(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    selfPermitIfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    stake(stakingPool: string, token: string, amount: BigNumberish, onBehalf: string, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    swap(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    swapWithPermit(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, permit: IRouter.SplitPermitParamsStruct, overrides?: PayableOverrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    vault(overrides?: CallOverrides): Promise<string>;
    wETH(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        addLiquidity(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        addLiquidity2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        addLiquidityWithPermit(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: CallOverrides): Promise<BigNumber>;
        addLiquidityWithPermit2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: CallOverrides): Promise<BigNumber>;
        burnLiquidity(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, overrides?: CallOverrides): Promise<IPool.TokenAmountStructOutput[]>;
        burnLiquiditySingle(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, overrides?: CallOverrides): Promise<IPool.TokenAmountStructOutput>;
        burnLiquiditySingleWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: CallOverrides): Promise<IPool.TokenAmountStructOutput>;
        burnLiquidityWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: CallOverrides): Promise<IPool.TokenAmountStructOutput[]>;
        createPool(_factory: string, data: BytesLike, overrides?: CallOverrides): Promise<string>;
        enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;
        enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;
        multicall(data: BytesLike[], overrides?: CallOverrides): Promise<string[]>;
        selfPermit(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: CallOverrides): Promise<void>;
        selfPermit2(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: CallOverrides): Promise<void>;
        selfPermit2IfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: CallOverrides): Promise<void>;
        selfPermitAllowed(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: CallOverrides): Promise<void>;
        selfPermitAllowedIfNecessary(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: CallOverrides): Promise<void>;
        selfPermitIfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: CallOverrides): Promise<void>;
        stake(stakingPool: string, token: string, amount: BigNumberish, onBehalf: string, overrides?: CallOverrides): Promise<void>;
        swap(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, overrides?: CallOverrides): Promise<IPool.TokenAmountStructOutput>;
        swapWithPermit(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, permit: IRouter.SplitPermitParamsStruct, overrides?: CallOverrides): Promise<IPool.TokenAmountStructOutput>;
        vault(overrides?: CallOverrides): Promise<string>;
        wETH(overrides?: CallOverrides): Promise<string>;
    };
    filters: {};
    estimateGas: {
        addLiquidity(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        addLiquidity2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        addLiquidityWithPermit(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        addLiquidityWithPermit2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        burnLiquidity(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        burnLiquiditySingle(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        burnLiquiditySingleWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        burnLiquidityWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        createPool(_factory: string, data: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;
        multicall(data: BytesLike[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        selfPermit(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        selfPermit2(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        selfPermit2IfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        selfPermitAllowed(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        selfPermitAllowedIfNecessary(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        selfPermitIfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        stake(stakingPool: string, token: string, amount: BigNumberish, onBehalf: string, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        swap(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        swapWithPermit(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, permit: IRouter.SplitPermitParamsStruct, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<BigNumber>;
        vault(overrides?: CallOverrides): Promise<BigNumber>;
        wETH(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        addLiquidity(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        addLiquidity2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        addLiquidityWithPermit(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        addLiquidityWithPermit2(pool: string, inputs: SyncSwapRouter.TokenInputStruct[], data: BytesLike, minLiquidity: BigNumberish, callback: string, callbackData: BytesLike, permits: IRouter.SplitPermitParamsStruct[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        burnLiquidity(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        burnLiquiditySingle(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        burnLiquiditySingleWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmount: BigNumberish, callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        burnLiquidityWithPermit(pool: string, liquidity: BigNumberish, data: BytesLike, minAmounts: BigNumberish[], callback: string, callbackData: BytesLike, permit: IRouter.ArrayPermitParamsStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        createPool(_factory: string, data: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        multicall(data: BytesLike[], overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        selfPermit(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        selfPermit2(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        selfPermit2IfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, signature: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        selfPermitAllowed(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        selfPermitAllowedIfNecessary(token: string, nonce: BigNumberish, expiry: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        selfPermitIfNecessary(token: string, value: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        stake(stakingPool: string, token: string, amount: BigNumberish, onBehalf: string, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        swap(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        swapWithPermit(paths: IRouter.SwapPathStruct[], amountOutMin: BigNumberish, deadline: BigNumberish, permit: IRouter.SplitPermitParamsStruct, overrides?: PayableOverrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        vault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        wETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

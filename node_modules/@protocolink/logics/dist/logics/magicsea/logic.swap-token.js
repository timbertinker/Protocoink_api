"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapTokenLogic = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const sdk_1 = require("@uniswap/sdk");
const contracts_1 = require("./contracts");
const utils_1 = require("../../utils");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const configs_1 = require("./configs");
const utils_2 = require("./utils");
class SwapTokenLogic extends core.Logic {
    async getTokenList() {
        const tokenListUrls = (0, configs_1.getTokenListUrls)(this.chainId);
        const tokenList = [this.nativeToken];
        const tmp = { [this.nativeToken.address]: true };
        await Promise.all(tokenListUrls.map(async (tokenListUrl) => {
            try {
                const { data } = await utils_1.axios.get(tokenListUrl);
                for (const { name, symbol, decimals, logoURI, address, chainId } of data.tokens) {
                    const lowerCaseAddress = address.toLowerCase();
                    if (tmp[lowerCaseAddress] ||
                        chainId !== this.chainId ||
                        !name ||
                        !symbol ||
                        !decimals ||
                        !ethers_1.ethers.utils.isAddress(address)) {
                        continue;
                    }
                    tokenList.push(new common.Token(chainId, address, decimals, symbol, name, logoURI));
                    tmp[lowerCaseAddress] = true;
                }
            }
            catch (_a) { }
        }));
        return tokenList;
    }
    async quote(params) {
        const maxHops = 3;
        const maxNumResults = 3;
        let path = [];
        let priceImpact = '0';
        if (core.isTokenToTokenExactInParams(params)) {
            const tradeType = core.TradeType.exactIn;
            const { input, slippage } = params;
            const tokenIn = input.token.wrapped;
            const tokenOut = params.tokenOut.wrapped;
            const pairs = await this.getAllCommonPairs((0, utils_2.toUniToken)(tokenIn), (0, utils_2.toUniToken)(tokenOut));
            const trade = sdk_1.Trade.bestTradeExactIn(pairs, (0, utils_2.toCurrencyAmount)(tokenIn, input.amountWei.toString()), (0, utils_2.toCurrency)(tokenOut), {
                maxHops,
                maxNumResults,
            })[0];
            let amountOut = '0';
            if (trade) {
                amountOut = trade.outputAmount.toFixed();
                path = trade.route.path.map((token) => token.address);
                priceImpact = trade.priceImpact.toFixed();
            }
            const output = new common.TokenAmount(params.tokenOut).set(amountOut);
            return {
                tradeType,
                input,
                output,
                path,
                priceImpact,
                slippage,
            };
        }
        else {
            const tradeType = core.TradeType.exactOut;
            const { output, slippage } = params;
            const tokenIn = params.tokenIn.wrapped;
            const tokenOut = output.token.wrapped;
            const pairs = await this.getAllCommonPairs((0, utils_2.toUniToken)(tokenIn), (0, utils_2.toUniToken)(tokenOut));
            const trade = sdk_1.Trade.bestTradeExactOut(pairs, (0, utils_2.toCurrency)(tokenIn), (0, utils_2.toCurrencyAmount)(tokenOut, output.amountWei.toString()), {
                maxHops,
                maxNumResults,
            })[0];
            let amountIn = '0';
            if (trade) {
                amountIn = slippage
                    ? trade.maximumAmountIn(new sdk_1.Percent(sdk_1.JSBI.BigInt(slippage), sdk_1.JSBI.BigInt(10000))).toFixed()
                    : trade.inputAmount.toFixed();
                path = trade.route.path.map((token) => token.address);
                priceImpact = trade.priceImpact.toFixed();
            }
            const input = new common.TokenAmount(params.tokenIn).set(amountIn);
            return {
                tradeType,
                input,
                output,
                path,
                priceImpact,
                slippage,
            };
        }
    }
    async build(fields, options) {
        const { tradeType, input, output, path, slippage, balanceBps } = fields;
        const { account } = options;
        const receiver = await this.calcAgent(account);
        const deadline = ethers_1.BigNumber.from(Math.floor(Date.now() / 1000)).add(1800); // 30m
        let data, inputs;
        if (tradeType === core.TradeType.exactIn) {
            const amountIn = input.amountWei;
            const amountOutMin = slippage ? common.calcSlippage(output.amountWei, slippage) : output.amountWei;
            data = contracts_1.MagicSeaRouter__factory.createInterface().encodeFunctionData('swapExactTokensForTokens', [
                amountIn,
                amountOutMin,
                path,
                receiver,
                deadline,
            ]);
            const amountOffset = balanceBps ? common.getParamOffset(0) : undefined;
            inputs = [
                core.newLogicInput({
                    input: new common.TokenAmount(input.token.wrapped, input.amount),
                    balanceBps,
                    amountOffset,
                }),
            ];
            const wrapMode = input.token.isNative
                ? core.WrapMode.wrapBefore
                : output.token.isNative
                    ? core.WrapMode.unwrapAfter
                    : core.WrapMode.none;
            return core.newLogic({ to: (0, configs_1.getContractAddress)(this.chainId, 'Router'), data, inputs, wrapMode });
        }
        else {
            const amountInMax = input.amountWei;
            const amountOut = output.amountWei;
            data = contracts_1.MagicSeaRouter__factory.createInterface().encodeFunctionData('swapTokensForExactTokens', [
                amountOut,
                amountInMax,
                path,
                receiver,
                deadline,
            ]);
            inputs = [
                core.newLogicInput({
                    input: new common.TokenAmount(input.token.wrapped, input.amount),
                }),
            ];
            const wrapMode = input.token.isNative
                ? core.WrapMode.wrapBefore
                : output.token.isNative
                    ? core.WrapMode.unwrapAfter
                    : core.WrapMode.none;
            return core.newLogic({ to: (0, configs_1.getContractAddress)(this.chainId, 'Router'), data, inputs, wrapMode });
        }
    }
    async getAllCommonPairs(tokenA, tokenB, isAll = true) {
        const pairTokens = this.generateAllRoutePairs(tokenA, tokenB);
        const pairAddresses = await this.getPairAddresses(pairTokens);
        const addresses = isAll ? pairAddresses : [pairAddresses[0]];
        const callsGetReserves = [];
        const iface = contracts_1.MagicSeaPair__factory.createInterface();
        for (let i = 0; i < addresses.length; i++) {
            const pairAddress = addresses[i];
            if (pairAddress) {
                const callDataGetReserves = iface.encodeFunctionData('getReserves');
                callsGetReserves.push({ target: pairAddress, callData: callDataGetReserves });
            }
        }
        const [resultsGetReserves] = await Promise.all([this.multicall3.callStatic.tryAggregate(false, callsGetReserves)]);
        let j = 0;
        const results = [];
        for (let i = 0; i < addresses.length; i++) {
            const pairAddress = addresses[i];
            if (!pairAddress) {
                results.push(['0', '0']);
            }
            else {
                const resultGetReserves = resultsGetReserves[j];
                if (resultGetReserves.success && resultGetReserves.returnData !== '0x') {
                    const [reserve0, reserve1] = iface.decodeFunctionResult('getReserves', resultGetReserves.returnData);
                    results.push([reserve0.toString(), reserve1.toString()]);
                }
                else {
                    results.push(['0', '0']);
                }
                j++;
            }
        }
        const pairs = results.reduce((accumulator, result, i) => {
            if (result) {
                const tokenA = pairTokens[i][0];
                const tokenB = pairTokens[i][1];
                const [reserve0, reserve1] = result;
                const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
                const pair = new sdk_1.Pair(new sdk_1.TokenAmount(token0, reserve0.toString()), new sdk_1.TokenAmount(token1, reserve1.toString()));
                accumulator.push(pair);
            }
            return accumulator;
        }, []);
        return pairs;
    }
    generateAllRoutePairs(tokenA, tokenB) {
        const allBases = (0, configs_1.getBaseTokens)(this.chainId).map((baseToken) => (0, utils_2.toUniToken)(baseToken));
        const basePairs = [];
        for (let i = 0; i < allBases.length; i++) {
            for (let j = i + 1; j < allBases.length; j++) {
                basePairs.push([allBases[i], allBases[j]]);
            }
        }
        return [
            // the direct pair
            [tokenA, tokenB],
            // token A against all bases
            ...allBases.map((base) => [tokenA, base]),
            // token B against all bases
            ...allBases.map((base) => [tokenB, base]),
            // each base against all bases
            ...basePairs,
        ]
            .filter((tokens) => Boolean(tokens[0] && tokens[1]))
            .filter(([t0, t1]) => t0.address !== t1.address);
    }
    async getPairAddresses(pairTokens) {
        const pairAddresses = [];
        const multicallRecords = [];
        const callsGetPair = [];
        const iface = contracts_1.MagicSeaFactory__factory.createInterface();
        // compose multi-calls
        for (let i = 0; i < pairTokens.length; i++) {
            const tokenA = pairTokens[i][0];
            const tokenB = pairTokens[i][1];
            if (tokenA && tokenB && !tokenA.equals(tokenB)) {
                const tokenIn = (0, utils_2.toToken)(tokenA);
                const tokenOut = (0, utils_2.toToken)(tokenB);
                const [token0, token1] = tokenIn.sortsBefore(tokenOut) ? [tokenIn, tokenOut] : [tokenOut, tokenIn];
                const callDataGetPair = iface.encodeFunctionData('getPair', [token0.address, token1.address]);
                const factorAddress = (0, configs_1.getContractAddress)(this.chainId, 'Factory');
                callsGetPair.push({ target: factorAddress, callData: callDataGetPair });
                multicallRecords.push(true);
            }
            else {
                multicallRecords.push(false);
            }
        }
        const [resultsGetPair] = await Promise.all([this.multicall3.callStatic.tryAggregate(false, callsGetPair)]);
        // decode multicall results
        let j = 0;
        for (let i = 0; i < multicallRecords.length; i++) {
            if (multicallRecords[i]) {
                const resultGetPair = resultsGetPair[j];
                if (resultGetPair.success && resultGetPair.returnData !== '0x') {
                    const [pairAddress] = iface.decodeFunctionResult('getPair', resultGetPair.returnData);
                    pairAddresses.push(pairAddress === ethers_1.constants.AddressZero ? undefined : pairAddress);
                }
                else {
                    pairAddresses.push(undefined);
                }
                j++;
            }
            else {
                pairAddresses.push(undefined);
            }
        }
        return pairAddresses;
    }
}
exports.SwapTokenLogic = SwapTokenLogic;
SwapTokenLogic.id = 'swap-token';
SwapTokenLogic.protocolId = 'magicsea';
SwapTokenLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.swap-token.js.map
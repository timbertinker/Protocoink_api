"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashLoanAggregatorLogic = exports.supportedFlashLoanLogics = void 0;
const tslib_1 = require("tslib");
const aavev2 = tslib_1.__importStar(require("../aave-v2"));
const aavev3 = tslib_1.__importStar(require("../aave-v3"));
const balancerv2 = tslib_1.__importStar(require("../balancer-v2"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
const morphoblue = tslib_1.__importStar(require("../morphoblue"));
const radiantv2 = tslib_1.__importStar(require("../radiant-v2"));
const spark = tslib_1.__importStar(require("../spark"));
exports.supportedFlashLoanLogics = [
    aavev2.FlashLoanLogic,
    aavev3.FlashLoanLogic,
    balancerv2.FlashLoanLogic,
    morphoblue.FlashLoanLogic,
    radiantv2.FlashLoanLogic,
    spark.FlashLoanLogic,
];
class FlashLoanAggregatorLogic extends core.Logic {
    async calcCallbackFee(protocolId, loan) {
        const FlashLoanLogic = exports.supportedFlashLoanLogics.find((Logic) => Logic.protocolId === protocolId);
        const flashLoanLogic = new FlashLoanLogic(this.chainId, this.provider);
        const callbackFee = await flashLoanLogic.calcCallbackFee(loan);
        return callbackFee;
    }
    async getTokenList() {
        const flashLoanLogics = exports.supportedFlashLoanLogics.filter((FlashLoanLogic) => FlashLoanLogic.supportedChainIds.includes(this.chainId));
        const allTokens = await Promise.all(flashLoanLogics.map((FlashLoanLogic) => {
            const flashLoanLogic = new FlashLoanLogic(this.chainId, this.provider);
            return flashLoanLogic.getTokenList();
        }));
        const tmp = {};
        const tokenList = [];
        for (const tokens of allTokens) {
            for (const token of tokens) {
                if (tmp[token.address])
                    continue;
                tokenList.push(token);
                tmp[token.address] = true;
            }
        }
        return tokenList;
    }
    async quote(params) {
        const { protocolId, ...others } = params;
        const flashLoanLength = core.isFlashLoanLoanParams(others) ? others.loans.length : others.repays.length;
        const flashLoanLogics = exports.supportedFlashLoanLogics.filter((FlashLoanLogic) => protocolId
            ? FlashLoanLogic.protocolId === protocolId
            : flashLoanLength > 1
                ? FlashLoanLogic.supportedChainIds.includes(this.chainId) && FlashLoanLogic.protocolId !== 'morphoblue'
                : FlashLoanLogic.supportedChainIds.includes(this.chainId));
        const quotations = [];
        await Promise.all(flashLoanLogics.map(async (FlashLoanLogic) => {
            const flashLoanLogic = new FlashLoanLogic(this.chainId, this.provider);
            try {
                const quotation = await flashLoanLogic.quote(others);
                quotations.push({
                    protocolId: FlashLoanLogic.protocolId,
                    callback: flashLoanLogic.callbackAddress,
                    ...quotation,
                });
            }
            catch (_a) { }
        }));
        let quotation;
        for (let i = 0; i < quotations.length; i++) {
            if (!quotation || quotations[i].feeBps < quotation.feeBps) {
                quotation = quotations[i];
            }
        }
        (0, tiny_invariant_1.default)(!!quotation, 'no suitable flash loan found');
        return quotation;
    }
    async build(fields) {
        const { protocolId, ...others } = fields;
        const FlashLoanLogic = exports.supportedFlashLoanLogics.find((Logic) => Logic.protocolId === protocolId);
        const routerLogic = await new FlashLoanLogic(this.chainId, this.provider).build(others);
        return routerLogic;
    }
}
exports.FlashLoanAggregatorLogic = FlashLoanAggregatorLogic;
FlashLoanAggregatorLogic.id = 'flash-loan-aggregator';
FlashLoanAggregatorLogic.protocolId = 'utility';
FlashLoanAggregatorLogic.supportedChainIds = Array.from(exports.supportedFlashLoanLogics.reduce((accumulator, FlashLoanLogic) => {
    for (const chainId of FlashLoanLogic.supportedChainIds) {
        accumulator.add(chainId);
    }
    return accumulator;
}, new Set())).sort((id1, id2) => id1 - id2);
//# sourceMappingURL=logic.flash-loan-aggregator.js.map
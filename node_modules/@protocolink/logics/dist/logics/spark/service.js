"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const types_1 = require("./types");
const common = tslib_1.__importStar(require("@protocolink/common"));
const ethers_1 = require("ethers");
const configs_1 = require("./configs");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
class Service extends common.Web3Toolkit {
    get poolDataProvider() {
        if (!this._poolDataProvider) {
            this._poolDataProvider = contracts_1.PoolDataProvider__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'PoolDataProvider'), this.provider);
        }
        return this._poolDataProvider;
    }
    get poolDataProviderIface() {
        if (!this._poolDataProviderIface) {
            this._poolDataProviderIface = contracts_1.PoolDataProvider__factory.createInterface();
        }
        return this._poolDataProviderIface;
    }
    get poolIface() {
        if (!this._poolIface) {
            this._poolIface = contracts_1.Pool__factory.createInterface();
        }
        return this._poolIface;
    }
    async getPoolAddress() {
        if (!this.poolAddress) {
            const addressProviderAddress = await this.poolDataProvider.ADDRESSES_PROVIDER();
            this.poolAddress = await contracts_1.PoolAddressesProvider__factory.connect(addressProviderAddress, this.provider).getPool();
        }
        return this.poolAddress;
    }
    async getReserveTokens() {
        if (!this.reserveTokens || !this.reserveMap) {
            const tokenAddresses = [];
            const reserveTokens = [];
            const reserveMap = {};
            const poolAddress = await this.getPoolAddress();
            const assetAddresses = await contracts_1.Pool__factory.connect(poolAddress, this.provider).getReservesList();
            const calls = assetAddresses.flatMap((assetAddress) => [
                {
                    target: this.poolDataProvider.address,
                    callData: this.poolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
                },
                {
                    target: this.poolDataProvider.address,
                    callData: this.poolDataProviderIface.encodeFunctionData('getReserveTokensAddresses', [assetAddress]),
                },
            ]);
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            assetAddresses.forEach((assetAddress, i) => {
                const { isActive, isFrozen, borrowingEnabled } = this.poolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[i * 2]);
                const { aTokenAddress, stableDebtTokenAddress, variableDebtTokenAddress } = this.poolDataProviderIface.decodeFunctionResult('getReserveTokensAddresses', returnData[i * 2 + 1]);
                reserveMap[assetAddress] = {
                    isSupplyEnabled: isActive && !isFrozen,
                    isBorrowEnabled: isActive && !isFrozen && borrowingEnabled,
                };
                tokenAddresses.push(assetAddress, aTokenAddress, stableDebtTokenAddress, variableDebtTokenAddress);
            });
            const tokens = await this.getTokens(tokenAddresses);
            for (let i = 0; i < tokens.length; i += 4) {
                const asset = tokens[i];
                const aToken = tokens[i + 1];
                const stableDebtToken = tokens[i + 2];
                const variableDebtToken = tokens[i + 3];
                const reserveToken = {
                    ...reserveMap[asset.address],
                    asset,
                    aToken,
                    stableDebtToken,
                    variableDebtToken,
                };
                reserveTokens.push(reserveToken);
                reserveMap[asset.address] = reserveToken;
                // Add aToken address as key for quick lookup
                reserveMap[aToken.address] = reserveToken;
            }
            this.reserveTokens = reserveTokens;
            this.reserveMap = reserveMap;
        }
        return { reserveTokens: this.reserveTokens, reserveMap: this.reserveMap };
    }
    async getAssets() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.map(({ asset }) => asset);
    }
    async getATokens() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.map(({ aToken }) => aToken);
    }
    async getSupplyTokens() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.filter(({ isSupplyEnabled }) => isSupplyEnabled);
    }
    async getBorrowTokens() {
        const { reserveTokens } = await this.getReserveTokens();
        return reserveTokens.filter(({ isBorrowEnabled }) => isBorrowEnabled);
    }
    async toAToken(asset) {
        var _a;
        const { reserveMap } = await this.getReserveTokens();
        const aToken = (_a = reserveMap[asset.wrapped.address]) === null || _a === void 0 ? void 0 : _a.aToken;
        (0, tiny_invariant_1.default)((aToken === null || aToken === void 0 ? void 0 : aToken.address) !== ethers_1.constants.AddressZero, `unsupported asset: ${asset.wrapped.address}`);
        return aToken;
    }
    async toATokens(assets) {
        const { reserveMap } = await this.getReserveTokens();
        return assets.map((asset) => {
            var _a;
            const aToken = (_a = reserveMap[asset.wrapped.address]) === null || _a === void 0 ? void 0 : _a.aToken;
            (0, tiny_invariant_1.default)((aToken === null || aToken === void 0 ? void 0 : aToken.address) !== ethers_1.constants.AddressZero, `unsupported asset: ${asset.wrapped.address}`);
            return aToken;
        });
    }
    async toAsset(aToken) {
        var _a;
        const { reserveMap } = await this.getReserveTokens();
        const asset = (_a = reserveMap[aToken.address]) === null || _a === void 0 ? void 0 : _a.asset;
        (0, tiny_invariant_1.default)(asset, `unsupported aToken: ${aToken.address}`);
        return asset;
    }
    async getDebtTokenAddress(asset, interestRateMode) {
        const { reserveMap } = await this.getReserveTokens();
        const { stableDebtToken, variableDebtToken } = reserveMap[asset.wrapped.address];
        (0, tiny_invariant_1.default)(stableDebtToken || variableDebtToken, `unsupported aToken: ${asset.wrapped.address}`);
        return interestRateMode === types_1.InterestRateMode.variable ? variableDebtToken.address : stableDebtToken.address;
    }
    async getFlashLoanPremiumTotal() {
        const poolAddress = await this.getPoolAddress();
        const premium = await contracts_1.Pool__factory.connect(poolAddress, this.provider).FLASHLOAN_PREMIUM_TOTAL();
        return premium.toNumber();
    }
    async isDelegationApproved(account, delegateeAddress, assetAmount, interestRateMode) {
        const debtTokenAddress = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const borrowAllowance = await contracts_1.DebtTokenBase__factory.connect(debtTokenAddress, this.provider).borrowAllowance(account, delegateeAddress);
        return borrowAllowance.gte(assetAmount.amountWei);
    }
    async buildApproveDelegationTransactionRequest(delegateeAddress, assetAmount, interestRateMode) {
        const to = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const iface = contracts_1.DebtTokenBase__factory.createInterface();
        const data = iface.encodeFunctionData('approveDelegation', [delegateeAddress, ethers_1.constants.MaxUint256]);
        return { to, data };
    }
    async getFlashLoanConfiguration(assets) {
        const aTokens = await this.toATokens(assets);
        const poolAddress = await this.getPoolAddress();
        const calls = [
            { target: poolAddress, callData: this.poolIface.encodeFunctionData('FLASHLOAN_PREMIUM_TOTAL') },
        ];
        for (let i = 0; i < assets.length; i++) {
            const assetAddress = assets[i].wrapped.address;
            calls.push({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getPaused', [assetAddress]),
            });
            calls.push({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
            });
            calls.push({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getFlashLoanEnabled', [assetAddress]),
            });
            calls.push({
                target: assetAddress,
                callData: this.erc20Iface.encodeFunctionData('balanceOf', [aTokens[i].address]),
            });
        }
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        let j = 0;
        const [premium] = this.poolIface.decodeFunctionResult('FLASHLOAN_PREMIUM_TOTAL', returnData[j]);
        const feeBps = premium.toNumber();
        j++;
        const assetInfos = [];
        for (let i = 0; i < assets.length; i++) {
            const [isPaused] = this.poolDataProviderIface.decodeFunctionResult('getPaused', returnData[j]);
            j++;
            const { isActive } = this.poolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[j]);
            j++;
            const [isFlashLoanEnabled] = this.poolDataProviderIface.decodeFunctionResult('getFlashLoanEnabled', returnData[j]);
            j++;
            const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[j]);
            const availableToBorrow = new common.TokenAmount(assets[i]).setWei(balance);
            j++;
            assetInfos.push({ isPaused, isActive, isFlashLoanEnabled, availableToBorrow });
        }
        return { feeBps: feeBps, assetInfos };
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map
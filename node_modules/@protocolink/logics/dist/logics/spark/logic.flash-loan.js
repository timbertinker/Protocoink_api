"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashLoanLogic = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const types_1 = require("./types");
const contracts_1 = require("./contracts");
const service_1 = require("./service");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const configs_1 = require("./configs");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
class FlashLoanLogic extends core.Logic {
    get callbackAddress() {
        return (0, configs_1.getContractAddress)(this.chainId, 'SparkFlashLoanCallback');
    }
    async calcCallbackFee(loan) {
        const callback = contracts_1.SparkFlashLoanCallback__factory.connect(this.callbackAddress, this.provider);
        const feeRate = await callback.feeRate();
        const callbackFee = new common.TokenAmount(loan.token).setWei(common.calcFee(loan.amountWei, feeRate.toNumber()));
        return callbackFee;
    }
    async getTokenList() {
        const service = new service_1.Service(this.chainId, this.provider);
        const tokens = await service.getAssets();
        const { assetInfos } = await service.getFlashLoanConfiguration(tokens);
        const tokenList = [];
        for (let i = 0; i < assetInfos.length; i++) {
            const { isActive, isPaused, isFlashLoanEnabled } = assetInfos[i];
            if (!isActive || isPaused || !isFlashLoanEnabled)
                continue;
            tokenList.push(tokens[i]);
        }
        return tokenList;
    }
    // The aave-v3-core forked by Spark
    // https://github.com/marsfoundation/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L386
    // https://github.com/marsfoundation/aave-v3-core/blob/master/contracts/protocol/libraries/logic/FlashLoanLogic.sol#L70
    // https://github.com/marsfoundation/aave-v3-core/blob/master/contracts/protocol/libraries/logic/FlashLoanLogic.sol#L94
    async quote(params) {
        const assets = core.isFlashLoanLoanParams(params)
            ? params.loans.map(({ token }) => token)
            : params.repays.map(({ token }) => token);
        const service = new service_1.Service(this.chainId, this.provider);
        const { feeBps, assetInfos } = await service.getFlashLoanConfiguration(assets);
        let loans;
        let repays;
        if (core.isFlashLoanLoanParams(params)) {
            ({ loans } = params);
            repays = new common.TokenAmounts();
            for (let i = 0; i < loans.length; i++) {
                const loan = loans.at(i);
                const { isActive, isPaused, isFlashLoanEnabled, availableToBorrow } = assetInfos[i];
                (0, tiny_invariant_1.default)(isActive, `asset is not active: ${loan.token.address}`);
                (0, tiny_invariant_1.default)(!isPaused, `asset is paused: ${loan.token.address}`);
                (0, tiny_invariant_1.default)(isFlashLoanEnabled, `asset can not be used in flash loan: ${loan.token.address}`);
                (0, tiny_invariant_1.default)(availableToBorrow.gte(loan), `insufficient borrowing capacity for the asset: ${loan.token.address}`);
                const feeAmountWei = common.calcFee(loan.amountWei, feeBps, 'round');
                const fee = new common.TokenAmount(loan.token).setWei(feeAmountWei);
                const repay = loan.clone().add(fee);
                repays.add(repay);
            }
        }
        else {
            loans = new common.TokenAmounts();
            repays = new common.TokenAmounts();
            for (let i = 0; i < params.repays.length; i++) {
                const repay = params.repays.at(i);
                const loanAmountWei = common.reverseAmountWithFee(repay.amountWei, feeBps);
                const loan = new common.TokenAmount(repay.token).setWei(loanAmountWei);
                loans.add(loan);
                const { isActive, isPaused, isFlashLoanEnabled, availableToBorrow } = assetInfos[i];
                (0, tiny_invariant_1.default)(isActive, `asset is not active: ${loan.token.address}`);
                (0, tiny_invariant_1.default)(!isPaused, `asset is paused: ${loan.token.address}`);
                (0, tiny_invariant_1.default)(isFlashLoanEnabled, `asset can not be used in flash loan: ${loan.token.address}`);
                (0, tiny_invariant_1.default)(availableToBorrow.gte(loan), `insufficient borrowing capacity for the asset: ${loan.token.address}`);
                const feeAmountWei = common.calcFee(loan.amountWei, feeBps, 'round');
                const fee = new common.TokenAmount(loan.token).setWei(feeAmountWei);
                repays.add(loan.clone().add(fee));
            }
        }
        const quotation = { loans, repays, feeBps };
        return quotation;
    }
    async build(fields) {
        const { loans, params, referralCode = 0 } = fields;
        const service = new service_1.Service(this.chainId, this.provider);
        const to = await service.getPoolAddress();
        const assets = [];
        const amounts = [];
        const modes = [];
        loans.forEach((loan) => {
            assets.push(loan.token.address);
            amounts.push(loan.amountWei);
            modes.push(types_1.InterestRateMode.none);
        });
        const data = contracts_1.Pool__factory.createInterface().encodeFunctionData('flashLoan', [
            this.callbackAddress,
            assets,
            amounts,
            modes,
            ethers_1.constants.AddressZero,
            params,
            referralCode,
        ]);
        const callback = this.callbackAddress;
        return core.newLogic({ to, data, callback });
    }
}
exports.FlashLoanLogic = FlashLoanLogic;
FlashLoanLogic.id = 'flash-loan';
FlashLoanLogic.protocolId = 'spark';
FlashLoanLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.flash-loan.js.map
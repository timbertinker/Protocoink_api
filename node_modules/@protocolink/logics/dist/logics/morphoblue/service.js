"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const common = tslib_1.__importStar(require("@protocolink/common"));
const configs_1 = require("./configs");
class Service extends common.Web3Toolkit {
    constructor() {
        super(...arguments);
        this.VIRTUAL_SHARES = 1e6;
        this.VIRTUAL_ASSETS = 1;
    }
    get morpho() {
        if (!this._morpho) {
            this._morpho = contracts_1.Morpho__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'Morpho'), this.provider);
        }
        return this._morpho;
    }
    get morphoIface() {
        if (!this._morphoIface) {
            this._morphoIface = contracts_1.Morpho__factory.createInterface();
        }
        return this._morphoIface;
    }
    async getLoanToken(marketId) {
        const market = (0, configs_1.getMarket)(this.chainId, marketId);
        const loanToken = await this.getToken(market.loanToken.address);
        return loanToken;
    }
    async getCollateralToken(marketId) {
        const market = (0, configs_1.getMarket)(this.chainId, marketId);
        const collateralToken = await this.getToken(market.collateralToken.address);
        return collateralToken;
    }
    async getSupplyBalance(marketId, account) {
        const loanToken = await this.getLoanToken(marketId);
        const { supplyShares } = await this.morpho.position(marketId, account);
        const { totalSupplyAssets, totalSupplyShares } = await this.morpho.market(marketId);
        const supplyBalance = this.toAssetsUp(supplyShares, totalSupplyAssets, totalSupplyShares);
        return new common.TokenAmount(loanToken).setWei(supplyBalance);
    }
    async getCollateralBalance(marketId, account) {
        const collateralToken = await this.getCollateralToken(marketId);
        const { collateral } = await this.morpho.position(marketId, account);
        return new common.TokenAmount(collateralToken).setWei(collateral);
    }
    async getBorrowBalance(marketId, account, loanToken) {
        if (!loanToken) {
            loanToken = await this.getLoanToken(marketId);
        }
        const borrowShares = await this.getBorrowShares(marketId, account);
        const { totalBorrowAssets, totalBorrowShares } = await this.morpho.market(marketId);
        const borrowBalance = this.toAssetsDown(borrowShares, totalBorrowAssets, totalBorrowShares);
        return new common.TokenAmount(loanToken).setWei(borrowBalance);
    }
    async getBorrowShares(marketId, account) {
        const { borrowShares } = await this.morpho.position(marketId, account);
        return borrowShares;
    }
    async isAuthorized(owner, manager) {
        return await this.morpho.isAuthorized(owner, manager);
    }
    buildAuthorizeTransactionRequest(manager, newIsAuthorized) {
        const to = this.morpho.address;
        const data = this.morphoIface.encodeFunctionData('setAuthorization', [manager, newIsAuthorized]);
        return { to, data };
    }
    // SharesMathlib
    // https://github.com/morpho-org/morpho-blue/blob/084721252cca3c40b8c289837b9ed3a33e54b36c/src/libraries/SharesMathLib.sol
    /// @dev Calculates the value of `assets` quoted in shares, rounding down.
    toSharedDown(assets, totalAssets, totalShares) {
        return this.mulDivDown(assets, totalShares.add(this.VIRTUAL_SHARES), totalAssets.add(this.VIRTUAL_ASSETS));
    }
    /// @dev Calculates the value of `shares` quoted in assets, rounding down.
    toAssetsDown(shares, totalAssets, totalShares) {
        return this.mulDivDown(shares, totalAssets.add(this.VIRTUAL_ASSETS), totalShares.add(this.VIRTUAL_SHARES));
    }
    /// @dev Calculates the value of `shares` quoted in assets, rounding up.
    toAssetsUp(shares, totalAssets, totalShares) {
        return this.mulDivUp(shares, totalAssets.add(this.VIRTUAL_ASSETS), totalShares.add(this.VIRTUAL_SHARES));
    }
    // Mathlib
    // https://github.com/morpho-org/morpho-blue/blob/084721252cca3c40b8c289837b9ed3a33e54b36c/src/libraries/MathLib.sol
    mulDivDown(x, y, d) {
        return x.mul(y).div(d);
    }
    mulDivUp(x, y, d) {
        return x.mul(y).add(d.sub(1)).div(d);
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashLoanLogic = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const service_1 = require("./service");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const configs_1 = require("./configs");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
class FlashLoanLogic extends core.Logic {
    get callbackAddress() {
        return (0, configs_1.getContractAddress)(this.chainId, 'MorphoFlashLoanCallback');
    }
    async calcCallbackFee(loan) {
        const callback = contracts_1.MorphoFlashLoanCallback__factory.connect(this.callbackAddress, this.provider);
        const feeRate = await callback.feeRate();
        const callbackFee = new common.TokenAmount(loan.token).setWei(common.calcFee(loan.amountWei, feeRate.toNumber()));
        return callbackFee;
    }
    async getTokenList() {
        const tokenAddressSet = new Set();
        const service = new service_1.Service(this.chainId, this.provider);
        const markets = (0, configs_1.getMarkets)(this.chainId);
        for (const market of markets) {
            tokenAddressSet.add(market.loanToken.address);
            tokenAddressSet.add(market.collateralToken.address);
        }
        const tokenList = await service.getTokens([...tokenAddressSet]);
        return tokenList;
    }
    async quote(params) {
        const assets = core.isFlashLoanLoanParams(params)
            ? params.loans.map(({ token }) => token)
            : params.repays.map(({ token }) => token);
        (0, tiny_invariant_1.default)(assets.length === 1, 'flashLoan more than one token');
        const morphoAddress = (0, configs_1.getContractAddress)(this.chainId, 'Morpho');
        const asset = assets[0];
        const calls = [
            {
                target: asset.address,
                callData: this.erc20Iface.encodeFunctionData('balanceOf', [morphoAddress]),
            },
        ];
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        const feeBps = 0;
        let loans;
        let repays;
        if (core.isFlashLoanLoanParams(params)) {
            ({ loans } = params);
            repays = new common.TokenAmounts();
            const loan = loans.at(0);
            const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[0]);
            const availableToBorrow = new common.TokenAmount(loan.token).setWei(balance);
            (0, tiny_invariant_1.default)(availableToBorrow.gte(loan), `insufficient borrowing capacity for the asset: ${loan.token.address}`);
            const feeAmountWei = common.calcFee(loan.amountWei, feeBps);
            const fee = new common.TokenAmount(loan.token).setWei(feeAmountWei);
            const repay = loan.clone().add(fee);
            repays.add(repay);
        }
        else {
            loans = new common.TokenAmounts();
            repays = new common.TokenAmounts();
            const repay = params.repays.at(0);
            const loanAmountWei = common.reverseAmountWithFee(repay.amountWei, feeBps);
            const loan = new common.TokenAmount(repay.token).setWei(loanAmountWei);
            loans.add(loan);
            const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[0]);
            const availableToBorrow = new common.TokenAmount(loan.token).setWei(balance);
            (0, tiny_invariant_1.default)(availableToBorrow.gte(loan), `insufficient borrowing capacity for the asset: ${loan.token.address}`);
            const feeAmountWei = common.calcFee(loan.amountWei, feeBps);
            const fee = new common.TokenAmount(loan.token).setWei(feeAmountWei);
            repays.add(loan.clone().add(fee));
        }
        const quotation = { loans, repays, feeBps };
        return quotation;
    }
    async build(fields) {
        const { loans, params } = fields;
        const to = this.callbackAddress;
        const loan = loans.toArray()[0];
        const asset = loan.token.address;
        const amount = loan.amountWei;
        const data = contracts_1.Morpho__factory.createInterface().encodeFunctionData('flashLoan', [asset, amount, params]);
        const callback = this.callbackAddress;
        return core.newLogic({ to, data, callback });
    }
}
exports.FlashLoanLogic = FlashLoanLogic;
FlashLoanLogic.id = 'flash-loan';
FlashLoanLogic.protocolId = 'morphoblue';
FlashLoanLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.flash-loan.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashLoanLogic = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const utils_1 = require("../../utils");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const configs_1 = require("./configs");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
class FlashLoanLogic extends core.Logic {
    get callbackAddress() {
        return (0, configs_1.getContractAddress)(this.chainId, 'BalancerV2FlashLoanCallback');
    }
    async calcCallbackFee(loan) {
        const callback = contracts_1.BalancerV2FlashLoanCallback__factory.connect(this.callbackAddress, this.provider);
        const feeRate = await callback.feeRate();
        const callbackFee = new common.TokenAmount(loan.token).setWei(common.calcFee(loan.amountWei, feeRate.toNumber()));
        return callbackFee;
    }
    async getTokenList() {
        const { data } = await utils_1.axios.get('https://raw.githubusercontent.com/balancer/tokenlists/main/generated/balancer.tokenlist.json');
        const tmp = {};
        const tokenList = [];
        for (const { chainId, address, decimals, symbol, name, logoURI } of data.tokens) {
            if (tmp[address] || chainId !== this.chainId || !name || !symbol || !decimals)
                continue;
            tokenList.push(new common.Token(chainId, address, decimals, symbol, name, logoURI));
            tmp[address] = true;
        }
        return tokenList;
    }
    async quote(params) {
        const assets = core.isFlashLoanLoanParams(params)
            ? params.loans.map(({ token }) => token)
            : params.repays.map(({ token }) => token);
        (0, tiny_invariant_1.default)(new Set(assets.map((asset) => asset.address)).size === assets.length, 'loans have duplicate tokens');
        const vaultAddress = (0, configs_1.getContractAddress)(this.chainId, 'Vault');
        const protocolFeesCollectorIface = contracts_1.ProtocolFeesCollector__factory.createInterface();
        const calls = [
            {
                target: (0, configs_1.getContractAddress)(this.chainId, 'ProtocolFeesCollector'),
                callData: protocolFeesCollectorIface.encodeFunctionData('getFlashLoanFeePercentage'),
            },
        ];
        assets.forEach((asset) => {
            calls.push({
                target: asset.address,
                callData: this.erc20Iface.encodeFunctionData('balanceOf', [vaultAddress]),
            });
        });
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        let j = 0;
        const [flashLoanFeePercentage] = protocolFeesCollectorIface.decodeFunctionResult('getFlashLoanFeePercentage', returnData[j]);
        const feeBps = flashLoanFeePercentage.toNumber();
        j++;
        let loans;
        let repays;
        if (core.isFlashLoanLoanParams(params)) {
            ({ loans } = params);
            repays = new common.TokenAmounts();
            for (let i = 0; i < loans.length; i++) {
                const loan = loans.at(i);
                const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[j]);
                const availableToBorrow = new common.TokenAmount(loan.token).setWei(balance);
                (0, tiny_invariant_1.default)(availableToBorrow.gte(loan), `insufficient borrowing capacity for the asset: ${loan.token.address}`);
                j++;
                const feeAmountWei = common.calcFee(loan.amountWei, feeBps);
                const fee = new common.TokenAmount(loan.token).setWei(feeAmountWei);
                const repay = loan.clone().add(fee);
                repays.add(repay);
            }
        }
        else {
            loans = new common.TokenAmounts();
            repays = new common.TokenAmounts();
            for (let i = 0; i < params.repays.length; i++) {
                const repay = params.repays.at(i);
                const loanAmountWei = common.reverseAmountWithFee(repay.amountWei, feeBps);
                const loan = new common.TokenAmount(repay.token).setWei(loanAmountWei);
                loans.add(loan);
                const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[j]);
                const availableToBorrow = new common.TokenAmount(loan.token).setWei(balance);
                (0, tiny_invariant_1.default)(availableToBorrow.gte(loan), `insufficient borrowing capacity for the asset: ${loan.token.address}`);
                j++;
                const feeAmountWei = common.calcFee(loan.amountWei, feeBps);
                const fee = new common.TokenAmount(loan.token).setWei(feeAmountWei);
                repays.add(loan.clone().add(fee));
            }
        }
        const quotation = { loans, repays, feeBps };
        return quotation;
    }
    async build(fields) {
        const { loans, params } = fields;
        const to = (0, configs_1.getContractAddress)(this.chainId, 'Vault');
        const assets = [];
        const amounts = [];
        for (const loan of common.sortByAddress(loans.toArray())) {
            assets.push(loan.token.address);
            amounts.push(loan.amountWei);
        }
        const data = contracts_1.Vault__factory.createInterface().encodeFunctionData('flashLoan', [
            this.callbackAddress,
            assets,
            amounts,
            params,
        ]);
        const callback = this.callbackAddress;
        return core.newLogic({ to, data, callback });
    }
}
exports.FlashLoanLogic = FlashLoanLogic;
FlashLoanLogic.id = 'flash-loan';
FlashLoanLogic.protocolId = 'balancer-v2';
FlashLoanLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.flash-loan.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapTokenLogic = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const contracts_1 = require("./contracts");
const common = tslib_1.__importStar(require("@protocolink/common"));
const core = tslib_1.__importStar(require("@protocolink/core"));
const configs_1 = require("./configs");
const common_1 = require("@protocolink/common");
class SwapTokenLogic extends core.Logic {
    async getTokenList() {
        const tokenLists = [];
        const srcTokens = [];
        // collect src tokens
        const STG = (0, configs_1.getSTGToken)(this.chainId);
        if (STG) {
            srcTokens.push(STG);
        }
        const markets = (0, configs_1.getMarkets)(this.chainId);
        for (const market of markets) {
            srcTokens.push(market.token);
        }
        // find destination ids and tokens
        for (const srcToken of srcTokens) {
            const destTokenLists = [];
            const destChainIds = (0, configs_1.getDestChainIds)(this.chainId, srcToken);
            for (const destChainId of destChainIds) {
                const destTokens = (0, configs_1.getDestTokens)(this.chainId, srcToken, destChainId);
                destTokenLists.push({ chainId: destChainId, tokens: destTokens });
            }
            tokenLists.push({ srcToken, destTokenLists });
        }
        return tokenLists;
    }
    async quote(params) {
        let output, fee;
        let feeBps = 0;
        const { input, tokenOut, receiver, slippage } = params;
        const destChainId = tokenOut.chainId;
        const destStargateChainId = (0, configs_1.getStargateChainId)(destChainId);
        if ((0, configs_1.isSTGToken)(this.chainId, input.token)) {
            const amountOut = input.amountWei;
            output = new common.TokenAmount(tokenOut, input.amount);
            const layerZeroEndpoint = contracts_1.LayerZeroEndpoint__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'LayerZeroEndpoint'), this.provider);
            [fee] = await layerZeroEndpoint.estimateFees(destStargateChainId, input.token.address, ethers_1.utils.defaultAbiCoder.encode(['bytes', 'uint256'], [ethers_1.utils.solidityPack(['address'], [receiver]), amountOut]), false, ethers_1.utils.solidityPack(['uint16', 'uint256'], [1, 85000]));
        }
        else {
            const [srcPoolId, destPoolId] = (0, configs_1.getPoolIds)(this.chainId, input.token, destChainId, tokenOut);
            const poolDecimals = (0, configs_1.getPoolDecimals)(this.chainId, srcPoolId);
            const amountIn = common.toSmallUnit(input.amount, poolDecimals);
            const feeLibrary = contracts_1.FeeLibrary__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'FeeLibrary'), this.provider);
            const { eqFee, eqReward, lpFee, protocolFee } = await feeLibrary.getFees(srcPoolId, destPoolId, (0, configs_1.getStargateChainId)(destChainId), receiver, amountIn);
            const totalFee = eqFee.add(lpFee).add(protocolFee).sub(eqReward);
            let amountOut = amountIn.sub(totalFee);
            if (tokenOut.decimals !== poolDecimals) {
                amountOut = common.toSmallUnit(common.toBigUnit(amountOut, poolDecimals), tokenOut.decimals);
            }
            feeBps = totalFee.mul(10000).div(amountIn).toNumber();
            const router = contracts_1.Router__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'Router'), this.provider);
            [fee] = await router.quoteLayerZeroFee(destStargateChainId, 1, receiver, '0x', {
                dstGasForCall: ethers_1.BigNumber.from(0),
                dstNativeAmount: 0,
                dstNativeAddr: '0x', // destination wallet for dust
            });
            output = new common.TokenAmount(tokenOut).setWei(amountOut);
        }
        return {
            input,
            output,
            fee: common.toBigUnit(fee, (0, common_1.getNativeToken)(this.chainId).decimals),
            feeBps,
            receiver,
            slippage,
        };
    }
    async build(fields, options) {
        const { input, output, fee, slippage, receiver, balanceBps } = fields;
        const destChainId = output.token.chainId;
        const { account } = options;
        const refundAddress = account;
        const amountIn = input.amountWei;
        const amountOutMin = slippage ? common.calcSlippage(output.amountWei, slippage) : output.amountWei;
        const destTo = ethers_1.utils.solidityPack(['address'], [receiver]);
        const destPayload = '0x'; // no payload
        const destStargateChainId = (0, configs_1.getStargateChainId)(destChainId);
        let to, data, inputs;
        if ((0, configs_1.isSTGToken)(this.chainId, input.token)) {
            to = input.token.address;
            data = contracts_1.StargateToken__factory.createInterface().encodeFunctionData('sendTokens', [
                destStargateChainId,
                destTo,
                amountIn,
                ethers_1.constants.AddressZero,
                ethers_1.utils.solidityPack(['uint16', 'uint256'], [1, 85000]), // adapterParameters {version, dstGas}
            ]);
            const amountOffset = balanceBps ? common.getParamOffset(2) : undefined;
            inputs = [
                core.newLogicInput({
                    input: new common.TokenAmount(input.token.wrapped, input.amount),
                    balanceBps,
                    amountOffset,
                }),
                core.newLogicInput({ input: new common.TokenAmount((0, common_1.getNativeToken)(this.chainId), fee) }),
            ];
        }
        else if (input.token.isNative && (0, configs_1.getContractAddress)(this.chainId, 'RouterETH')) {
            to = (0, configs_1.getContractAddress)(this.chainId, 'RouterETH');
            data = contracts_1.RouterETH__factory.createInterface().encodeFunctionData('swapETH', [
                destStargateChainId,
                refundAddress,
                destTo,
                amountIn,
                amountOutMin,
            ]);
            const amountOffset = balanceBps ? common.getParamOffset(3) : undefined;
            inputs = [
                core.newLogicInput({
                    input: new common.TokenAmount(input.token.unwrapped, input.amount),
                    balanceBps,
                    amountOffset,
                }),
                core.newLogicInput({ input: new common.TokenAmount((0, common_1.getNativeToken)(this.chainId), fee) }),
            ];
        }
        else {
            to = (0, configs_1.getContractAddress)(this.chainId, 'Router');
            const [srcPoolId, destPoolId] = (0, configs_1.getPoolIds)(this.chainId, input.token, destChainId, output.token);
            data = contracts_1.Router__factory.createInterface().encodeFunctionData('swap', [
                destStargateChainId,
                srcPoolId,
                destPoolId,
                refundAddress,
                amountIn,
                amountOutMin,
                {
                    dstGasForCall: ethers_1.BigNumber.from(0),
                    dstNativeAmount: 0,
                    dstNativeAddr: '0x', // destination wallet for dust
                },
                destTo,
                destPayload,
            ]);
            const amountOffset = balanceBps ? common.getParamOffset(4) : undefined;
            inputs = [
                core.newLogicInput({
                    input: new common.TokenAmount(input.token.wrapped, input.amount),
                    balanceBps,
                    amountOffset,
                }),
                core.newLogicInput({ input: new common.TokenAmount((0, common_1.getNativeToken)(this.chainId), fee) }),
            ];
        }
        const wrapMode = core.WrapMode.none;
        return core.newLogic({ to, data, inputs, wrapMode });
    }
}
exports.SwapTokenLogic = SwapTokenLogic;
SwapTokenLogic.id = 'swap-token';
SwapTokenLogic.protocolId = 'stargate';
SwapTokenLogic.supportedChainIds = configs_1.supportedChainIds;
//# sourceMappingURL=logic.swap-token.js.map
import type { Address, ConstructFetchInput } from '../../types';
import type { LimitOrderFromApi, LimitOrdersApiResponse, LimitOrderType } from './helpers/types';
declare type PaginationParams = {
    limit?: number;
    offset?: number;
    hideSmallBalances?: boolean;
    orderBy?: 'createdAt' | 'updatedAt' | 'expiry';
};
export declare type LimitOrdersUserParams = ({
    maker: Address;
    type: LimitOrderType;
} | {
    taker: Address;
    type: LimitOrderType;
}) & PaginationParams;
export declare type GetRequiredAllowanceParams = {
    maker: Address;
    token?: Address;
};
declare type GetLimitOrderByHash = (orderHash: string, signal?: AbortSignal) => Promise<LimitOrderFromApi>;
declare type GetLimitOrders = (userParams: LimitOrdersUserParams, signal?: AbortSignal) => Promise<LimitOrdersApiResponse>;
declare type GetRequiredBalance = (userParams: GetRequiredAllowanceParams, singal?: AbortSignal) => Promise<Record<string, string>>;
export declare type GetLimitOrdersFunctions = {
    getLimitOrders: GetLimitOrders;
    getLimitOrderByHash: GetLimitOrderByHash;
    /**
     * Gets fillableBalance for tokens from user's active orders.
     * User needs to have enough balance & allowance to cover active orders before creating new orders.
     * @param userParams - parameters to get allowance for active orders
     * @param {string} userParams.maker - user to get required allowances for
     * @param {string=} userParams.token - if given `token`, the mapping will contain that token address only
     * @param {AbortSignal=} signal - AbortSignal passed to fetcher
     * @returns `{Lowercase<Address> => wei number as string}` mapping of token to fillableBalance
     */
    getRequiredBalance: GetRequiredBalance;
};
export declare const constructGetLimitOrders: ({ apiURL, chainId, fetcher, }: ConstructFetchInput) => GetLimitOrdersFunctions;
export {};
//# sourceMappingURL=getOrders.d.ts.map
{"version":3,"file":"sdk.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/constants.ts","../src/helpers/misc.ts","../src/methods/swap/spender.ts","../src/helpers/approve.ts","../src/methods/swap/approve.ts","../src/helpers/token.ts","../src/methods/swap/balance.ts","../src/methods/swap/adapters.ts","../src/methods/swap/helpers/normalizeRateOptions.ts","../src/methods/swap/rates.ts","../src/methods/swap/swapTx.ts","../src/methods/swap/token.ts","../src/methods/common/orders/buildOrderData.ts","../src/methods/common/orders/misc.ts","../src/methods/limitOrders/helpers/misc.ts","../src/methods/nftOrders/helpers/buildOrderData.ts","../src/methods/nftOrders/helpers/misc.ts","../src/methods/swap/transaction.ts","../src/methods/limitOrders/helpers/buildOrderData.ts","../src/methods/limitOrders/buildOrder.ts","../src/methods/limitOrders/signOrder.ts","../src/methods/limitOrders/cancelOrder.ts","../src/methods/limitOrders/fillOrderDirectly.ts","../src/methods/limitOrders/getOrders.ts","../src/methods/limitOrders/postOrder.ts","../src/methods/limitOrders/approveForOrder.ts","../src/methods/limitOrders/getOrdersContract.ts","../src/methods/limitOrders/transaction.ts","../src/methods/nftOrders/buildOrder.ts","../src/methods/nftOrders/signOrder.ts","../src/methods/nftOrders/cancelOrder.ts","../src/methods/nftOrders/getOrders.ts","../src/methods/nftOrders/postOrder.ts","../src/methods/nftOrders/getOrdersContract.ts","../src/methods/nftOrders/approveForOrder.ts","../src/methods/nftOrders/transaction.ts","../src/helpers/fetchers/axios.ts","../src/helpers/fetchers/fetch.ts","../src/helpers/providers/ethers.ts","../src/helpers/providers/web3.ts","../src/sdk/partial.ts","../src/methods/swap/index.ts","../src/methods/limitOrders/index.ts","../src/methods/nftOrders/index.ts","../src/legacy/index.ts","../src/sdk/full.ts","../src/sdk/simple.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { ParaSwapVersionUnion } from './types';\n\nexport {\n  SwapSide,\n  ContractMethod,\n  ContractMethodV5,\n  ContractMethodV6,\n} from '@paraswap/core';\n\nexport const API_URL = 'https://api.paraswap.io';\nexport const DEFAULT_VERSION: ParaSwapVersionUnion = '5';\n","import type {\n  Contract as EthersContract,\n  ContractFunction as EthersContractFunction,\n  PopulatedTransaction as EthersPopulatedTransaction,\n  BigNumber as EthersBigNumber,\n} from 'ethers';\nimport type {\n  ContractSendMethod as Web3ContractSendMethod,\n  Contract as Web3Contract,\n} from 'web3-eth-contract';\nimport { assert, Primitive } from 'ts-essentials';\n\nimport type { AxiosError } from 'axios';\n\nexport type EthersContractWithMethod<T extends string> = EthersContract & {\n  readonly [method in T]: EthersContractFunction;\n} & {\n  readonly functions: { [method in T]: EthersContractFunction };\n\n  readonly callStatic: { [method in T]: EthersContractFunction };\n  readonly estimateGas: {\n    [method in T]: EthersContractFunction<EthersBigNumber>;\n  };\n  readonly populateTransaction: {\n    [method in T]: EthersContractFunction<EthersPopulatedTransaction>;\n  };\n};\n\nexport function ethersContractHasMethods<T extends string>(\n  contract: EthersContract,\n  ...methods: T[]\n): contract is EthersContractWithMethod<T> {\n  return methods.every((method) => typeof contract[method] === 'function');\n}\n\nexport function assertEthersContractHasMethods<T extends string>(\n  contract: EthersContract,\n  ...methods: T[]\n): asserts contract is EthersContractWithMethod<T> {\n  assert(\n    ethersContractHasMethods(contract, ...methods),\n    `Contract must have methods: ${methods.join(', ')}`\n  );\n}\n\nexport type Web3ContractWithMethod<T extends string> = Web3Contract & {\n  methods: { [method in T]: Web3ContractSendMethod };\n};\n\nexport function web3ContractHasMethods<T extends string>(\n  contract: Web3Contract,\n  ...methods: T[]\n): contract is Web3ContractWithMethod<T> {\n  return methods.every(\n    (method) => typeof contract.methods[method] === 'function'\n  );\n}\n\nexport function assertWeb3ContractHasMethods<T extends string>(\n  contract: Web3Contract,\n  ...methods: T[]\n): asserts contract is Web3ContractWithMethod<T> {\n  assert(\n    web3ContractHasMethods(contract, ...methods),\n    `Contract must have methods: ${methods.join(', ')}`\n  );\n}\n\nexport const objectToFilledEntries = <T extends Record<string, unknown>>(\n  object: T\n): [string, string][] => {\n  return (\n    Object.entries(object)\n      // removes keys with undefined values\n      .filter(([, value]) => value !== undefined)\n      .map(([key, value]) => [key, String(value)])\n  );\n};\n\n//                                                            not arrays or mappings\nexport const constructSearchString = <\n  U extends Record<string, Exclude<Primitive, symbol>>\n>(\n  queryOptions: U\n): `?${string}` | '' => {\n  const queryEntries = objectToFilledEntries(queryOptions);\n\n  const queryString = new URLSearchParams(queryEntries).toString();\n\n  // returns empty string or `?${string}`\n  return queryString && `?${queryString}`;\n};\n\ntype FetcherErrorConstructorInput = Pick<\n  AxiosError,\n  'code' | 'request' | 'response' | 'isAxiosError' | 'message'\n>;\n\nexport interface FetcherErrorInterface extends FetcherErrorConstructorInput {\n  status?: number;\n  code?: string;\n}\n\nexport const isFetcherError = (error: unknown): error is FetcherError => {\n  return error instanceof FetcherError;\n};\n\nexport class FetcherError extends Error implements FetcherErrorInterface {\n  code;\n  status;\n  request;\n  response;\n  isAxiosError = false;\n\n  public constructor({\n    code,\n    request,\n    response,\n    isAxiosError,\n    message,\n  }: FetcherErrorConstructorInput) {\n    super();\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FetcherError);\n    }\n\n    this.name = this.constructor.name;\n    this.code = code;\n    this.request = request;\n    this.isAxiosError = isAxiosError;\n\n    // no response on AxiosError\n    if (!response) {\n      this.message = message;\n      return;\n    }\n\n    this.response = response;\n\n    const { data, status } = response;\n    this.status = status;\n    this.message = isDataWithError(data) ? data.error : message;\n  }\n}\n// to turn `object -> Record` for indexed variable access\nfunction isObject(obj: unknown): obj is Record<string | symbol, any> {\n  return !!obj && typeof obj === 'object';\n}\n\nexport function isDataWithError(data: unknown): data is { error: string } {\n  return isObject(data) && typeof data['error'] === 'string';\n}\n\nexport type ExtractAbiMethodNames<T extends readonly { name: string }[]> =\n  T[number]['name'];\n\n// reduce element[] to Object{key: prop, val?: element}\n// for example\n// gatherObjectsByProp(Token[], token => token.address) => Record<address, Token|undefined>\nexport function gatherObjectsByProp<T>(\n  elements: T[],\n  pickProp: (elem: T, index: number) => string\n): Record<string, T>;\nexport function gatherObjectsByProp<T, U>(\n  elements: T[],\n  pickProp: (elem: T, index: number) => string,\n  transfrom: (elem: T, accumElem: U | undefined, index: number) => U\n): Record<string, U>;\nexport function gatherObjectsByProp<T, U>(\n  elements: T[],\n  pickProp: (elem: T, index: number) => string,\n  transform?: (elem: T, accumElem: U | undefined, index: number) => U\n): Record<string, T> | Record<string, U> {\n  return elements.reduce<Record<string, T> | Record<string, U>>(\n    (accum, element, index) => {\n      const key = pickProp(element, index);\n\n      const accumElem: T | U | undefined = accum[key];\n      const transformedElement = transform\n        ? //                       if transform is available, can only be U | undefined\n          transform(element, accumElem as U | undefined, index)\n        : element;\n\n      accum[key] = transformedElement;\n\n      return accum;\n    },\n    {}\n  );\n}\n\n// checks that array has at least one element\nexport const isFilledArray = <T>(array: T[]): array is [T, ...T[]] => {\n  return array.length > 0;\n};\n\nexport function getRandomInt(): number {\n  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n}\n\nexport function runOnceAndCache<T, Args extends any[]>(\n  // can pass `(...any[]) => any but null | undefined`\n  func: (...args: Args) => NonNullable<T>\n): (...args: Args) => NonNullable<T> {\n  let result: NonNullable<T>;\n\n  return (...args) => {\n    return result ?? (result = func(...args));\n  };\n}\n","import { API_URL, DEFAULT_VERSION } from '../../constants';\nimport { constructSearchString, runOnceAndCache } from '../../helpers/misc';\nimport type { ConstructFetchInput, Address } from '../../types';\n\nexport type GetSpender = (signal?: AbortSignal) => Promise<Address>;\ntype GetContracts = (signal?: AbortSignal) => Promise<AdaptersContractsResult>;\n\nexport type GetSpenderFunctions = {\n  getSpender: GetSpender;\n  getAugustusSwapper: GetSpender;\n  getAugustusRFQ: GetSpender;\n  getContracts: GetContracts;\n};\n\ninterface AdaptersContractsResult {\n  AugustusSwapper: string;\n  TokenTransferProxy: string;\n  AugustusRFQ: string;\n}\n\nexport const constructGetSpender = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetSpenderFunctions => {\n  const search = constructSearchString<{ network: number; version: string }>({\n    network: chainId,\n    version,\n  });\n\n  const fetchURL = `${apiURL}/adapters/contracts${search}` as const;\n\n  const _getContracts: GetContracts = async (signal) => {\n    const data = await fetcher<AdaptersContractsResult>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    return data;\n  };\n\n  // cached for the same instance of `{getContracts, getSpender, getAugustusSwapper, getAugustusRFQ} = constructGetSpender()`\n  // so should persist across same apiUrl & network\n  const getContracts = runOnceAndCache(_getContracts);\n\n  const getSpender: GetSpender = async (signal) => {\n    const { TokenTransferProxy } = await getContracts(signal);\n    return TokenTransferProxy;\n  };\n\n  const getAugustusSwapper: GetSpender = async (signal) => {\n    const { AugustusSwapper } = await getContracts(signal);\n    return AugustusSwapper;\n  };\n\n  const getAugustusRFQ: GetSpender = async (signal) => {\n    const { AugustusRFQ } = await getContracts(signal);\n    return AugustusRFQ;\n  };\n\n  return { getContracts, getSpender, getAugustusSwapper, getAugustusRFQ };\n};\n","import type { ConstructProviderFetchInput, TxSendOverrides } from '../types';\nimport type { ExtractAbiMethodNames } from '../helpers/misc';\nimport type { Address, PriceString } from './token';\n\n// much smaller than the whole ERC20_ABI\nconst MinERC20Abi = [\n  {\n    constant: false,\n    inputs: [\n      { name: '_spender', type: 'address' },\n      { name: '_value', type: 'uint256' },\n    ],\n    name: 'approve',\n    outputs: [{ name: '', type: 'bool' }],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype ApprovalMethods = ExtractAbiMethodNames<typeof MinERC20Abi>;\n\ntype ApproveContractCaller<T> = ConstructProviderFetchInput<\n  T,\n  'transactCall'\n>['contractCaller'];\n\nexport type ApproveToken<T> = (\n  amount: PriceString,\n  tokenAddress: Address,\n  overrides?: TxSendOverrides,\n  signal?: AbortSignal\n) => Promise<T>;\n\nexport type GetSpenderAsyncOrSync = (\n  signal?: AbortSignal\n) => Address | Promise<Address>;\n\nexport function approveTokenMethodFactory<T>(\n  contractCaller: ApproveContractCaller<T>,\n  getSpender: GetSpenderAsyncOrSync\n): ApproveToken<T> {\n  return async (amount, tokenAddress, overrides = {}, signal) => {\n    const spender = await getSpender(signal);\n\n    const res = await contractCaller.transactCall<ApprovalMethods>({\n      address: tokenAddress,\n      abi: MinERC20Abi,\n      contractMethod: 'approve',\n      args: [spender, amount],\n      overrides,\n    });\n\n    return res;\n  };\n}\n","import { constructGetSpender } from './spender';\nimport type {\n  ConstructProviderFetchInput,\n  TxSendOverrides,\n  Address,\n  PriceString,\n} from '../../types';\nimport { ApproveToken, approveTokenMethodFactory } from '../../helpers/approve';\n\ntype ApproveTokenBulk<T> = (\n  amount: PriceString,\n  tokenAddresses: Address[],\n  overrides?: TxSendOverrides,\n  signal?: AbortSignal\n) => Promise<Awaited<T>[]>;\n\nexport type ApproveTokenFunctions<T> = {\n  approveToken: ApproveToken<T>;\n  approveTokenBulk: ApproveTokenBulk<T>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructApproveToken = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): ApproveTokenFunctions<T> => {\n  // getSpender is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getSpender } = constructGetSpender(options);\n\n  const approveToken: ApproveToken<T> = approveTokenMethodFactory<T>(\n    options.contractCaller,\n    getSpender\n  );\n\n  const approveTokenBulk: ApproveTokenBulk<T> = async (\n    amount,\n    tokenAddresses,\n    overrides,\n    signal\n  ) => {\n    return Promise.all(\n      tokenAddresses.map((tokenAddress) =>\n        approveToken(amount, tokenAddress, overrides, signal)\n      )\n    );\n  };\n\n  return { approveToken, approveTokenBulk };\n};\n","import type { MarkOptional } from 'ts-essentials';\n\n/**\n * @type hex token or account address\n */\nexport type Address = string;\n/**\n * @type hex token address or token symbol\n */\nexport type AddressOrSymbol = string;\n/**\n * @type number in string form\n */\nexport type PriceString = string;\n/**\n * @type transaction hash\n */\nexport type TxHash = string;\n\n// @TODO sync with what it actually is\nexport type LendingToken =\n  | 'cToken'\n  | 'iToken'\n  | 'aToken'\n  | 'aToken2'\n  | 'idleToken'\n  | 'Chai'\n  | 'bDAI';\n\nexport type TokenType = 'ETH' | 'ERC20' | 'SYNTH';\n\n/**\n * @type Token object returned from API used internally in API\n */\n// consider if need the old class Token for backwards compatipility\n// otherwise no real need\nexport type Token = {\n  address: string;\n  decimals: number;\n  symbol?: string | undefined;\n  tokenType: LendingToken | TokenType;\n  mainConnector: string;\n  connectors: string[];\n  network: number;\n  img?: string | undefined;\n  allowance?: string | undefined;\n  balance?: string | undefined;\n};\n\ntype ConstructTokenInput = MarkOptional<\n  Token,\n  // these props are constructed from other, required props\n  'tokenType' | 'mainConnector' | 'connectors' | 'network'\n>;\n\nexport const constructToken = (tokenProps: ConstructTokenInput): Token => {\n  const {\n    tokenType = 'ERC20',\n    mainConnector = 'ETH',\n    connectors: connectorsInput = [],\n    network = 1,\n    ...rest\n  } = tokenProps;\n\n  const connectors: Token['connectors'] =\n    connectorsInput.length > 0 ? connectorsInput : [mainConnector];\n\n  return {\n    tokenType,\n    connectors,\n    mainConnector,\n    network,\n    ...rest,\n  };\n};\n","import { API_URL } from '../../constants';\nimport {\n  Token,\n  Address,\n  constructToken,\n  AddressOrSymbol,\n} from '../../helpers/token';\nimport type {\n  ConstructFetchInput,\n  TokenApiResponse,\n  TokensApiResponse,\n} from '../../types';\n\ntype GetBalances = (\n  userAddress: Address,\n  signal?: AbortSignal\n) => Promise<Token[]>;\ntype GetBalance = (\n  userAddress: Address,\n  tokenAddressOrSymbol: AddressOrSymbol,\n  signal?: AbortSignal\n) => Promise<Token | typeof NOT_FOUND_RESPONSE>;\n\nexport interface Allowance {\n  tokenAddress: Address;\n  allowance: string;\n}\n\ntype GetAllowances = (\n  userAddress: Address,\n  tokenAddresses: Address[],\n  signal?: AbortSignal\n) => Promise<Allowance[]>;\ntype GetAllowance = (\n  userAddress: Address,\n  tokenAddress: Address,\n  signal?: AbortSignal\n) => Promise<Allowance | typeof NOT_FOUND_RESPONSE>;\n\nexport const isAllowance = (\n  arg: Awaited<ReturnType<GetAllowance>>\n): arg is Allowance => {\n  return 'allowance' in arg;\n};\n\nexport type GetBalancesFunctions = {\n  getBalance: GetBalance;\n  getBalances: GetBalances;\n  getAllowance: GetAllowance;\n  getAllowances: GetAllowances;\n};\n\nconst NOT_FOUND_RESPONSE = { message: 'Not Found' } as const;\n\nexport const constructGetBalances = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetBalancesFunctions => {\n  const tokensUrl = `${apiURL}/users/tokens/${chainId}` as const;\n\n  const getBalances: GetBalances = async (userAddress, signal) => {\n    const fetchURL = `${tokensUrl}/${userAddress}` as const;\n\n    const data = await fetcher<TokensApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    const tokens = data.tokens.map(constructToken);\n\n    return tokens;\n  };\n\n  const getBalance: GetBalance = async (\n    userAddress,\n    tokenAddressOrSymbol,\n    signal\n  ) => {\n    const fetchURL =\n      `${tokensUrl}/${userAddress}/${tokenAddressOrSymbol}` as const;\n\n    const data = await fetcher<TokenApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    if (!data.token) {\n      return NOT_FOUND_RESPONSE;\n    }\n\n    return constructToken(data.token);\n  };\n\n  const getAllowances: GetAllowances = async (\n    userAddress,\n    tokenAddresses,\n    signal\n  ) => {\n    const tokenAddressesLowercaseSet = new Set(\n      tokenAddresses.map((address) => address.toLowerCase())\n    );\n\n    const balances = await getBalances(userAddress, signal);\n\n    const allowances: Allowance[] = balances\n      .filter((token) =>\n        tokenAddressesLowercaseSet.has(token.address.toLowerCase())\n      )\n      .map(({ address, allowance = '0' }) => ({\n        tokenAddress: address,\n        allowance,\n      }));\n\n    return allowances;\n  };\n\n  const getAllowance: GetAllowance = async (\n    userAddress,\n    tokenAddress,\n    signal\n  ) => {\n    const balanceOrNotFound = await getBalance(\n      userAddress,\n      tokenAddress,\n      signal\n    );\n\n    if ('message' in balanceOrNotFound) {\n      return balanceOrNotFound;\n    }\n\n    const { address, allowance = '0' } = balanceOrNotFound;\n\n    return { tokenAddress: address, allowance };\n  };\n\n  return {\n    getBalance,\n    getBalances,\n    getAllowance,\n    getAllowances,\n  };\n};\n","import type { ConstructFetchInput, ParaSwapVersionUnion } from '../../types';\nimport { constructSearchString } from '../../helpers/misc';\nimport { API_URL, DEFAULT_VERSION } from '../../constants';\n\ntype AdaptersAsStrings = string[];\n\nexport type GetAdaptersFunctions = {\n  getAdapters: (signal?: AbortSignal) => Promise<AdaptersAsStrings>;\n};\n\ntype SearchStringParams = {\n  network: number;\n  version?: ParaSwapVersionUnion;\n};\n\nexport const constructGetAdapters = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetAdaptersFunctions => {\n  const getAdapters: GetAdaptersFunctions['getAdapters'] = async (\n    signal?: AbortSignal\n  ): Promise<AdaptersAsStrings> => {\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const query = constructSearchString<SearchStringParams>({\n      network: chainId,\n      version,\n    });\n\n    const fetchURL = `${apiURL}/adapters/list${query}` as const;\n\n    const data = await fetcher<AdaptersAsStrings>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    return data;\n  };\n\n  return { getAdapters };\n};\n","import type { PickKeys } from 'ts-essentials';\nimport type { RateOptions } from '../rates';\n\ntype StringArrKeys = PickKeys<RateOptions, string[] | undefined>;\n\ntype MinRateOptionsInput = Pick<RateOptions, StringArrKeys> &\n  Pick<RateOptions, 'partner'>;\n\ntype NormalizedRateOptions<\n  O extends MinRateOptionsInput,\n  T extends { options?: Partial<O> }\n> = Partial<Record<StringArrKeys | 'partner', string>> &\n  Partial<Omit<O, StringArrKeys | 'partner'>> &\n  Omit<T, 'options'>;\n\nconst DEFAULT_PARTNER = 'paraswap.io';\n\nexport function normalizeRateOptions<\n  O extends MinRateOptionsInput,\n  T extends { options?: Partial<O> }\n>({ options = {}, ...restInput }: T): NormalizedRateOptions<O, T> {\n  const {\n    excludePricingMethods,\n    excludeContractMethods,\n    includeContractMethods,\n    partner = DEFAULT_PARTNER,\n    includeDEXS,\n    excludeDEXS,\n    excludePools,\n    ...restOptions\n  } = options;\n\n  const [\n    _includeDEXS,\n    _excludeDEXS,\n    _excludePools,\n    _excludePricingMethods,\n    _excludeContractMethods,\n    _includeContractMethods,\n  ] = [\n    includeDEXS,\n    excludeDEXS,\n    excludePools,\n    excludePricingMethods,\n    excludeContractMethods,\n    includeContractMethods,\n    //                                                                                              no \"\" empty string\n  ].map((array) => array?.join(',') || undefined);\n\n  const transformed: Partial<Record<StringArrKeys | 'partner', string>> = {\n    excludePricingMethods: _excludePricingMethods,\n    excludeContractMethods: _excludeContractMethods,\n    includeContractMethods: _includeContractMethods,\n    partner,\n    includeDEXS: _includeDEXS,\n    excludeDEXS: _excludeDEXS,\n    excludePools: _excludePools,\n  };\n\n  return { ...transformed, ...restOptions, ...restInput };\n}\n","import { ContractMethod, API_URL, DEFAULT_VERSION } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type {\n  ConstructFetchInput,\n  PriceRouteApiResponse,\n  Address,\n  AddressOrSymbol,\n  PriceString,\n  OptimalRate,\n} from '../../types';\nimport { normalizeRateOptions } from './helpers/normalizeRateOptions';\n\n// TODO: This is legacy and can be removed\nexport enum PricingMethod {\n  megapath = 'megapath',\n  multipath = 'multipath',\n  simplepath = 'simplepath',\n}\n\ntype RateQueryParams = {\n  /**\n   * @description Source Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  srcToken: string;\n\n  /**\n   * @description Source Token Decimals. (Can be omitted if Token Symbol is used in `srcToken`).\n   */\n  srcDecimals?: number;\n\n  /**\n   * @description Destination Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  destToken: string;\n\n  /**\n   * @description srcToken amount (in case of SELL) or destToken amount (in case of BUY). The amount should be in **WEI/Raw units** (eg. 1WBTC -> 100000000).\n   */\n  amount: string;\n\n  /**\n   * @description **SELL** or **BUY**. Default: `SELL`.\n   */\n  side?: 'SELL' | 'BUY';\n\n  /**\n   * @description Network ID. (Mainnet - 1, Optimism - 10, BSC - 56, Polygon - 137, Fantom - 250, zkEVM - 1101, Base - 8453, Arbitrum - 42161, Avalanche - 43114). Default: `1`.\n   */\n  network?: number;\n\n  /**\n   * @description If provided, **others** object is filled in the response with price quotes from other exchanges _(if available for comparison)_. Default: `false`.\n   */\n  otherExchangePrices?: boolean;\n\n  /**\n   * @description Comma Separated List of DEXs to include. **Supported DEXs:** UniswapV2, UniswapV3, Kyber, Bancor, AugustusRFQ, Oasis, Compound, Fulcrum, Balancer, MakerDAO, Chai, Aave, Aave2 and more. You can view all currently supported dexes filtered by chain [here](https://api.paraswap.io/adapters/list/1) eg: `UniswapV3,MakerDAO`.\n   */\n  includeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of DEXs to exclude. (from the list of DEXs mentioned above).\n   */\n  excludeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to include in pricing (without spaces). View the list of the supported methods for [V5](https://developers.paraswap.network/api/master/api-v5#supported-methods) and [V6](https://developers.paraswap.network/api/master/api-v6.2#supported-methods) eg: `swapExactAmountIn,swapExactAmountInOnUniswapV2`.\n   */\n  includeContractMethods?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to exclude from pricing (without spaces). View the list of the supported methods for [V5](https://developers.paraswap.network/api/master/api-v5#supported-methods) and [V6](https://developers.paraswap.network/api/master/api-v6.2#supported-methods).\n   */\n  excludeContractMethods?: string;\n\n  /**\n   * @description User's Wallet Address.\n   */\n  userAddress?: string;\n\n  /**\n   * @description Dash (-) separated list of tokens (addresses or symbols from `/tokens`) to comprise the price route. _Max 4 tokens._ _**\\*Note:**_ _If_ `_route_` _is specified, the response will only comprise of the route specified which might not be the optimal route._\n   */\n  route?: string;\n\n  /**\n   * @description Partner string.\n   */\n  partner?: string;\n\n  /**\n   * @description Destination Token Decimals. (Can be omitted if Token Symbol is used in `destToken`).\n   */\n  destDecimals?: number;\n\n  /**\n   * @description In %. It's a way to bypass the API price impact check (default = 15%).\n   */\n  maxImpact?: number;\n\n  /**\n   * @description Receiver's Wallet address. (Can be omitted if swapping tokens from and to same account).\n   */\n  receiver?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  srcTokenTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  destTokenTransferFee?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.\n   */\n  srcTokenDexTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs, not on ordinary transfers.\n   */\n  destTokenDexTransferFee?: string;\n\n  /**\n   * @description To specify the protocol version. **Values:** 5 or 6.2 **Default**: 5.\n   */\n  version?: number | string;\n\n  /**\n   * @description Specify that methods without fee support should be excluded from the price route. Default: `false`.\n   */\n  excludeContractMethodsWithoutFeeModel?: boolean;\n\n  /**\n   * @description If tokens USD prices are not available, `Bad USD Price` error will be thrown. Use this param to skip this check. Default: `false`.\n   */\n  ignoreBadUsdPrice?: boolean;\n  /**\n   * @description \tExclude all RFQs from pricing, e.g.: AugustusRFQ, Hashflow. Default: false\n   */\n  excludeRFQ?: boolean;\n};\n\n// more details in the docs https://developers.paraswap.network/api/get-rate-for-a-token-pair#query-parameters\nexport type RateOptions = {\n  excludeDEXS?: string[];\n  includeDEXS?: string[];\n  excludePools?: string[];\n  excludePricingMethods?: PricingMethod[];\n  excludeContractMethods?: ContractMethod[];\n  includeContractMethods?: ContractMethod[];\n  partner?: string;\n  /** @description In %. It's a way to bypass the API price impact check (default = 15%) */\n  maxImpact?: number;\n  maxUSDImpact?: number;\n  otherExchangePrices?: boolean;\n  /** @description proceed with priceRoute building even when tokens don't have USD price. Default: false */\n  ignoreBadUsdPrice?: boolean;\n  /** @description Exclude all RFQs from pricing, e.g.: AugustusRFQ, Hashflow. Default: false */\n  excludeRFQ?: boolean;\n  /** @description \tSpecify that methods without fee support should be excluded from the price route. Default: false */\n  excludeContractMethodsWithoutFeeModel?: boolean;\n  /** @description If the source token is a tax token, you should specify the tax amount in BPS.  */\n  srcTokenTransferFee?: string;\n  /** @description If the destination token is a tax token, you should specify the tax amount in BPS.  */\n  destTokenTransferFee?: string;\n  /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */\n  srcTokenDexTransferFee?: string;\n  /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */\n  destTokenDexTransferFee?: string;\n};\n\ntype CommonGetRateInput = {\n  amount: PriceString;\n  userAddress?: Address;\n  side?: 'SELL' | 'BUY';\n  options?: RateOptions;\n  srcDecimals?: number;\n  destDecimals?: number;\n};\n\nexport type GetRateInput = CommonGetRateInput & {\n  srcToken: AddressOrSymbol;\n  destToken: AddressOrSymbol;\n};\n\nexport type GetRate = (\n  options: GetRateInput,\n  signal?: AbortSignal\n) => Promise<OptimalRate>;\n\ntype GetRateByRouteInput = CommonGetRateInput & {\n  route: AddressOrSymbol[];\n};\n\ntype GetRateByRoute = (\n  options: GetRateByRouteInput,\n  signal?: AbortSignal\n) => Promise<OptimalRate>;\n\nexport type GetRateFunctions = {\n  getRate: GetRate;\n  getRateByRoute: GetRateByRoute;\n};\nconst INVALID_ROUTE = 'Invalid Route';\n\nexport const constructGetRate = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetRateFunctions => {\n  const pricesUrl = `${apiURL}/prices` as const;\n\n  const getRate: GetRate = async ({ srcToken, destToken, ...rest }, signal) => {\n    const parsedOptions = normalizeRateOptions(rest);\n\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const search = constructSearchString<Omit<RateQueryParams, 'route'>>({\n      srcToken,\n      destToken,\n      network: chainId,\n      version,\n      ...parsedOptions,\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<PriceRouteApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    return data.priceRoute;\n  };\n\n  const getRateByRoute: GetRateByRoute = async ({ route, ...rest }, signal) => {\n    if (route.length < 2) {\n      throw new Error(INVALID_ROUTE);\n    }\n\n    const parsedOptions = normalizeRateOptions(rest);\n\n    const _route = route.join('-');\n\n    const search = constructSearchString<\n      Omit<RateQueryParams, 'srcToken' | 'destToken'>\n    >({\n      route: _route, // route can be used in place of srcToken+destToken\n      network: chainId,\n      version,\n      ...parsedOptions,\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<PriceRouteApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    return data.priceRoute;\n  };\n\n  return {\n    getRate,\n    getRateByRoute,\n  };\n};\n","import { ContractMethod, API_URL, DEFAULT_VERSION } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type { ConstructFetchInput, SwapApiResponse } from '../../types';\nimport { normalizeRateOptions } from './helpers/normalizeRateOptions';\n\n/**\n * Types for transaction parameters.\n */\ntype SwapQueryParams = {\n  /**\n   * @description Source Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  srcToken: string;\n\n  /**\n   * @description Source Token Decimals. (Can be omitted if Token Symbol is used in `srcToken`).\n   */\n  srcDecimals?: number;\n\n  /**\n   * @description Destination Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  destToken: string;\n\n  /**\n   * @description srcToken amount (in case of SELL) or destToken amount (in case of BUY). The amount should be in **WEI/Raw units** (eg. 1WBTC -> 100000000).\n   */\n  amount: string;\n\n  /**\n   * @description **SELL** or **BUY**. Default: `SELL`.\n   */\n  side: 'SELL' | 'BUY';\n\n  /**\n   * @description Network ID. (Mainnet - 1, Optimism - 10, BSC - 56, Polygon - 137, Fantom - 250, zkEVM - 1101, Base - 8453, Arbitrum - 42161, Avalanche - 43114). Default: `1`.\n   */\n  network?: number;\n\n  /**\n   * @description Comma Separated List of DEXs to include. **Supported DEXs:** Uniswap, Kyber, Bancor, AugustusRFQ, Oasis, Compound, Fulcrum, 0x, MakerDAO, Chai, Aave, Aave2, MultiPath, MegaPath, Curve, Curve3, Saddle, IronV2, BDai, idle, Weth, Beth, UniswapV2, Balancer, 0xRFQt, SushiSwap, LINKSWAP, Synthetix, DefiSwap, Swerve, CoFiX, Shell, DODOV1, DODOV2, OnChainPricing, PancakeSwap, PancakeSwapV2, ApeSwap, Wbnb, acryptos, streetswap, bakeryswap, julswap, vswap, vpegswap, beltfi, ellipsis, QuickSwap, COMETH, Wmatic, Nerve, Dfyn, UniswapV3, Smoothy, PantherSwap, OMM1, OneInchLP, CurveV2, mStable, WaultFinance, MDEX, ShibaSwap, CoinSwap, SakeSwap, JetSwap, Biswap, BProtocol eg: `UniswapV3,0x`.\n   */\n  includeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of DEXs to exclude. (from the list of DEXs mentioned above).\n   */\n  excludeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to include without spaces. **Available values:** swapOnUniswap, buyOnUniswap, swapOnUniswapFork, buyOnUniswapFork, swapOnUniswapV2Fork, buyOnUniswapV2Fork, simpleBuy, simpleSwap, multiSwap, megaSwap, protectedMultiSwap, protectedMegaSwap, protectedSimpleSwap, protectedSimpleBuy, swapOnZeroXv2, swapOnZeroXv4, buy. eg: `simpleSwap,multiSwap`.\n   */\n  includeContractMethods?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to exclude without spaces. (from the list of contract methods mentioned above).\n   */\n  excludeContractMethods?: string;\n\n  /**\n   * @description User's Wallet Address.\n   */\n  userAddress: string;\n\n  /**\n   * @description Dash (-) separated list of tokens (addresses or symbols from `/tokens`) to comprise the price route. _Max 4 tokens._ _**\\*Note:**_ _If_ `_route_` _is specified, the response will only comprise of the route specified which might not be the optimal route._\n   */\n  route?: string;\n\n  /**\n   * @description Partner string.\n   */\n  partner?: string;\n\n  /**\n   * @description If provided it is used together with `partnerAddress`. Should be in basis points percentage. Look at `slippage` parameter description for understanding better. Eg: `200` (for 2% fee percent). Fees have to be claimed from the Fee Claimer contract unless `_isSurplusToUser_` or `_isDirectFeeTransfer_` are used.\n   */\n  partnerFeeBps?: string;\n\n  /**\n   * @description Address that will be entitled to claim fees or surplus. Fees have to be claimed from the Fee Claimer contract unless `_isSurplusToUser_` or `_isDirectFeeTransfer_` are used.\n   */\n  partnerAddress?: string;\n\n  /**\n   * @description Allowed slippage percentage represented in basis points. _Eg:_ for **2.5%** slippage, set the value to **2.5 \\* 100 = 250**; for 10% = 1000.\n   */\n  slippage: number;\n\n  /**\n   * @description Destination Token Decimals. (Can be omitted if Token Symbol is used in `destToken`).\n   */\n  destDecimals?: number;\n\n  /**\n   * @description In %. It's a way to bypass the API price impact check (default = 15%).\n   */\n  maxImpact?: number;\n\n  /**\n   * @description Receiver's Wallet address. (Can be omitted if swapping tokens from and to same account).\n   */\n  receiver?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  srcTokenTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  destTokenTransferFee?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.\n   */\n  srcTokenDexTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs, not on ordinary transfers.\n   */\n  destTokenDexTransferFee?: string;\n\n  /**\n   * @description To specify the protocol version. **Values:** 5 or 6.2 **Default**: 5.\n   */\n  version?: number | string;\n\n  /**\n   * @description If tokens USD prices are not available, `Bad USD Price` error will be thrown. Use this param to skip this check. Default: `false`.\n   */\n  ignoreBadUsdPrice?: boolean;\n\n  /**\n   * @description Specify if user should receive surplus instead of partner. Default: `false`.\n   */\n  isSurplusToUser?: boolean;\n\n  /**\n   * @description Specify if fees should be sent directly to the partner instead of registering them on FeeClaimer. Default: `false`.\n   */\n  isDirectFeeTransfer?: boolean;\n\n  /**\n   * @description Allows for capping the surplus at 1% maximum. Default: `true`.\n   */\n  isCapSurplus?: boolean;\n\n  /**\n   * @description Allows to collect surplus. Works with `partnerAddress`. Default: `false`.\n   */\n  takeSurplus?: boolean;\n};\n\ntype SwapTxInputFields =\n  | 'srcToken'\n  | 'destToken'\n  | 'amount'\n  | 'side'\n  | 'srcDecimals'\n  | 'destDecimals'\n  | 'userAddress'\n  | 'slippage';\ntype SwapTxInputListFields =\n  | 'includeDEXS'\n  | 'excludeDEXS'\n  | 'includeContractMethods'\n  | 'excludeContractMethods'\n  | 'route';\n\ntype SwapRateOptions = Omit<\n  SwapQueryParams,\n  SwapTxInputFields | SwapTxInputListFields | 'network' | 'version'\n> & {\n  /**\n   * @description List of DEXs to include. **Supported DEXs:** Uniswap, Kyber, Bancor, AugustusRFQ, Oasis, Compound, Fulcrum, 0x, MakerDAO, Chai, Aave, Aave2, MultiPath, MegaPath, Curve, Curve3, Saddle, IronV2, BDai, idle, Weth, Beth, UniswapV2, Balancer, 0xRFQt, SushiSwap, LINKSWAP, Synthetix, DefiSwap, Swerve, CoFiX, Shell, DODOV1, DODOV2, OnChainPricing, PancakeSwap, PancakeSwapV2, ApeSwap, Wbnb, acryptos, streetswap, bakeryswap, julswap, vswap, vpegswap, beltfi, ellipsis, QuickSwap, COMETH, Wmatic, Nerve, Dfyn, UniswapV3, Smoothy, PantherSwap, OMM1, OneInchLP, CurveV2, mStable, WaultFinance, MDEX, ShibaSwap, CoinSwap, SakeSwap, JetSwap, Biswap, BProtocol eg: `UniswapV3,0x`.\n   */\n  includeDEXS?: string[];\n\n  /**\n   * @description List of DEXs to exclude. (from the list of DEXs mentioned above).\n   */\n  excludeDEXS?: string[];\n\n  /**\n   * @description List of Contract Methods to include without spaces. **Available values:** swapOnUniswap, buyOnUniswap, swapOnUniswapFork, buyOnUniswapFork, swapOnUniswapV2Fork, buyOnUniswapV2Fork, simpleBuy, simpleSwap, multiSwap, megaSwap, protectedMultiSwap, protectedMegaSwap, protectedSimpleSwap, protectedSimpleBuy, swapOnZeroXv2, swapOnZeroXv4, buy. eg: `simpleSwap,multiSwap`.\n   */\n  includeContractMethods?: ContractMethod[];\n\n  /**\n   * @description List of Contract Methods to exclude without spaces. (from the list of contract methods mentioned above).\n   */\n  excludeContractMethods?: ContractMethod[];\n};\n\ntype SwapTxInput = Pick<SwapQueryParams, SwapTxInputFields> & {\n  /**\n   * @description List of tokens (addresses or symbols from `/tokens`) to comprise the price route. _Max 4 tokens._ _**\\*Note:**_ _If_ `_route_` _is specified, the response will only comprise of the route specified which might not be the optimal route._\n   */\n  route?: string[];\n\n  options?: SwapRateOptions;\n};\n\nexport type SwapTxResult = SwapApiResponse;\n\nexport type GetSwapTxData = (\n  options: SwapTxInput,\n  signal?: AbortSignal\n) => Promise<SwapTxResult>;\n\nexport type GetSwapTxFunctions = {\n  getSwapTxData: GetSwapTxData;\n};\n\nexport const constructSwapTx = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetSwapTxFunctions => {\n  const pricesUrl = `${apiURL}/swap` as const;\n\n  const getSwapTxData: GetSwapTxData = async (\n    { srcToken, destToken, amount, route, ...rest },\n    signal\n  ) => {\n    const parsedOptions = normalizeRateOptions(rest);\n\n    const _route = route?.join('-');\n\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const search = constructSearchString<SwapQueryParams>({\n      amount,\n      srcToken,\n      destToken,\n      route: _route,\n      network: chainId,\n      version,\n      ...parsedOptions,\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<SwapApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    return data;\n  };\n\n  return {\n    getSwapTxData,\n  };\n};\n","import { API_URL } from '../../constants';\nimport { constructToken } from '../../helpers/token';\nimport type {\n  ConstructFetchInput,\n  Token,\n  TokensApiResponse,\n} from '../../types';\n\ntype GetTokens = (signal?: AbortSignal) => Promise<Token[]>;\n\nexport type GetTokensFunctions = {\n  getTokens: GetTokens;\n};\n\nexport const constructGetTokens = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetTokensFunctions => {\n  const fetchURL = `${apiURL}/tokens/${chainId}` as const;\n\n  const getTokens: GetTokens = async (signal) => {\n    const data = await fetcher<TokensApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    const tokens = data.tokens.map(constructToken);\n    return tokens;\n  };\n\n  return { getTokens };\n};\n","import type {\n  TypedDataDomain as EthersTypedDataDomain,\n  TypedDataField,\n} from '@ethersproject/abstract-signer';\n\nexport const name = 'AUGUSTUS RFQ';\nexport const version = '1';\nexport const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\n\ntype TypedDataDomain = Omit<EthersTypedDataDomain, 'chainId'> & {\n  chainId: number;\n};\n\nexport type SignableTypedData = {\n  types: Record<string, TypedDataField[]>;\n  domain: TypedDataDomain;\n  data: Record<string, any>;\n};\n\nexport type Domain = {\n  name: string;\n  version: string;\n  chainId: number;\n  verifyingContract: string;\n};\n","import type { LimitOrderFromApi } from '../../limitOrders/helpers/types';\nimport { ZERO_ADDRESS } from './buildOrderData';\nimport type { OrderType } from './types';\n\ntype GetBaseFetchUrlInput = {\n  apiURL: string;\n  chainId: number;\n};\n\nexport type BaseFetchUrlInputConstructor<Kind extends OrderKind> = (\n  params: GetBaseFetchUrlInput\n) => UrlByTypeFunction<Kind>;\n\ntype OrderType2URLPart = {\n  LIMIT: 'orders';\n  P2P: 'p2p';\n};\n\ntype OrderKind = 'nft' | 'ft';\n\nexport type BaseFetchUrl<\n  Kind extends OrderKind,\n  Type extends OrderType = OrderType\n> = `${string}/${Kind}/${OrderType2URLPart[Type]}/${number}`;\n\nexport type MinFetchUrl<Kind extends OrderKind> = `${string}/${Kind}/order`;\nexport type OrderFillableBalanceFetchUrl<Kind extends OrderKind> =\n  `${string}/${Kind}/fillablebalance/${number}`;\n\ninterface UrlByTypeFunction<Kind extends OrderKind> {\n  (): MinFetchUrl<Kind>;\n  (type: 'LIMIT'): BaseFetchUrl<Kind, 'LIMIT'>;\n  (type: 'P2P'): BaseFetchUrl<Kind, 'P2P'>;\n  (type: OrderType): BaseFetchUrl<Kind>;\n  (type: 'fillablebalance'): OrderFillableBalanceFetchUrl<Kind>;\n  (type?: OrderType | 'fillablebalance'):\n    | BaseFetchUrl<Kind>\n    | MinFetchUrl<Kind>\n    | OrderFillableBalanceFetchUrl<Kind>;\n}\n\nexport function baseFetchUrlGetterFactory<Kind extends OrderKind>(\n  orderKind: Kind\n): BaseFetchUrlInputConstructor<Kind> {\n  return function constructBaseFetchUrlGetter({\n    chainId,\n    apiURL,\n  }: GetBaseFetchUrlInput): UrlByTypeFunction<Kind> {\n    function urlGetter(type: 'LIMIT'): BaseFetchUrl<Kind, 'LIMIT'>;\n    function urlGetter(type: 'P2P'): BaseFetchUrl<Kind, 'P2P'>;\n    function urlGetter(type: OrderType): BaseFetchUrl<Kind>;\n    function urlGetter(\n      type: 'fillablebalance'\n    ): OrderFillableBalanceFetchUrl<Kind>;\n    function urlGetter(): MinFetchUrl<Kind>;\n    function urlGetter(\n      type?: OrderType | 'fillablebalance'\n    ):\n      | BaseFetchUrl<Kind>\n      | MinFetchUrl<Kind>\n      | OrderFillableBalanceFetchUrl<Kind> {\n      if (!type) return `${apiURL}/${orderKind}/order` as const;\n\n      if (type === 'fillablebalance')\n        return `${apiURL}/${orderKind}/fillablebalance/${chainId}` as const;\n\n      const orderURLpart = type === 'LIMIT' ? 'orders' : 'p2p';\n      return `${apiURL}/${orderKind}/${orderURLpart}/${chainId}` as const;\n    }\n\n    return urlGetter;\n  };\n}\n\n// orders with taker = EOA address\n// that can't be filled through AugustusSwapper,\n// only through AugustusRFQ\nexport function isOrderFillableDirectlyOnRFQOnly(\n  order: Pick<LimitOrderFromApi, 'taker' | 'takerFromMeta'>\n): boolean {\n  // with 0x taker fillable by anyone\n  if (order.taker === ZERO_ADDRESS) return false;\n\n  // same intended EOA taker and msg.sender taker\n  return order.taker.toLowerCase() === order.takerFromMeta.toLowerCase();\n}\n","import {\n  BaseFetchUrl,\n  baseFetchUrlGetterFactory,\n  BaseFetchUrlInputConstructor,\n  MinFetchUrl,\n  OrderFillableBalanceFetchUrl,\n} from '../../common/orders/misc';\nimport type { OrderData } from './buildOrderData';\n\nexport function sanitizeOrderData({\n  nonceAndMeta,\n  expiry,\n  makerAsset,\n  takerAsset,\n  maker,\n  taker,\n  makerAmount,\n  takerAmount,\n}: OrderData & Record<string, any>): OrderData {\n  return {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker,\n    makerAmount,\n    takerAmount,\n  };\n}\n\n/* \nGET\n/ft/orders/:chainId/maker/:walletAddress\n/ft/orders/:chainId/taker/:walletAddress\n/ft/p2p/:chainId/maker/:walletAddress\n/ft/p2p/:chainId/taker/:walletAddress\n*/\nexport type GetOrdersURLs = `${BaseFetchUrl<'ft'>}/${\n  | 'taker'\n  | 'maker'}/${string}`;\n\n/*\nGET\n/ft/fillablebalance/:chainId/:walletAddress/:makerAsset?\n*/\nexport type GetRequiredAllowanceURL =\n  `${OrderFillableBalanceFetchUrl<'ft'>}/${string}${`/${string}` | ''}`;\n\n/*\nGET\n/ft/order/:orderHash (get you p2p or orders)\n*/\nexport type GetOrderURL = `${MinFetchUrl<'ft'>}/${string}`;\n\n/* \nPOST create order\n/ft/orders/:chainId/\n/ft/p2p/:chainId/\n*/\nexport type PostOrderURLs = BaseFetchUrl<'ft'>;\n\nexport const constructBaseFetchUrlGetter: BaseFetchUrlInputConstructor<'ft'> =\n  baseFetchUrlGetterFactory('ft');\n","import type { Address } from '../../../types';\nimport type { AssetTypeVariant } from './types';\nimport {\n  Domain,\n  name,\n  version,\n  ZERO_ADDRESS,\n} from '../../common/orders/buildOrderData';\nimport { getRandomInt } from '../../../helpers/misc';\n\nconst OrderNFT = [\n  { name: 'nonceAndMeta', type: 'uint256' },\n  { name: 'expiry', type: 'uint128' },\n  { name: 'makerAsset', type: 'uint256' },\n  { name: 'makerAssetId', type: 'uint256' },\n  { name: 'takerAsset', type: 'uint256' },\n  { name: 'takerAssetId', type: 'uint256' },\n  { name: 'maker', type: 'address' },\n  { name: 'taker', type: 'address' },\n  { name: 'makerAmount', type: 'uint256' },\n  { name: 'takerAmount', type: 'uint256' },\n];\n\nexport interface BuildNFTOrderDataInput {\n  chainId: number;\n  verifyingContract: Address;\n  nonce?: number;\n  expiry: number;\n  makerAsset: Address;\n  takerAsset: Address;\n  makerAmount: string;\n  takerAmount: string;\n  /** @description NFT Token id, will default to 0 (ERC20), provide for NFT */\n  makerAssetId: string; // required when BUYing NFT\n  /** @description NFT Token id, will default to 0 (ERC20), provide for NFT */\n  takerAssetId?: string;\n  /** @description Token type: ERC20 = 0, ERC1155 = 1, ERC721 = 2 */\n  makerAssetType: AssetTypeVariant;\n  /** @description Token type: ERC20 = 0, ERC1155 = 1, ERC721 = 2 */\n  takerAssetType: AssetTypeVariant;\n  maker: Address;\n  // OrderData.taker must be Augustus for p2p limitOrders to involve swap through Augustus\n  // this is the actual user taker which will go into nonceAndMeta\n  taker?: Address;\n  AugustusAddress: Address;\n}\n\nexport type SignableNFTOrderData = {\n  types: { OrderNFT: typeof OrderNFT };\n  domain: Domain;\n  data: NFTOrderData;\n};\n\nexport type BigIntAsString = string;\n\nexport type NFTOrderData = {\n  expiry: number;\n  // '1' when trading 1 NFT token\n  makerAmount: BigIntAsString;\n  makerAsset: BigIntAsString;\n  // '0' indicates ERC20\n  makerAssetId: BigIntAsString;\n  // '1' when trading 1 NFT token\n  takerAmount: BigIntAsString;\n  takerAsset: BigIntAsString;\n  // '0' indicates ERC20\n  takerAssetId: BigIntAsString;\n  nonceAndMeta: BigIntAsString;\n  maker: Address;\n  taker: Address;\n};\n\nexport function buildOrderData({\n  chainId,\n  verifyingContract,\n  nonce = getRandomInt(),\n  expiry,\n  makerAsset: _makerAssetAddress,\n  takerAsset: _takerAssetAddress,\n  makerAmount,\n  takerAmount,\n  makerAssetId,\n  takerAssetId = '0',\n  makerAssetType,\n  takerAssetType,\n  maker,\n  AugustusAddress,\n  // if taker is specified -- p2p order for that taker only to fill through Augustus -- taker = Augustus, takerInNonce = _taker\n  // if taker is not specified -- limitOrder for anyone to fill through Augustus -- taker = Augustus, takerInNonce = Zero\n  taker: takerInNonce = ZERO_ADDRESS, //@TODO allow Orders outside of AugustusRFQ\n}: BuildNFTOrderDataInput): SignableNFTOrderData {\n  // first 160 bits is taker address (for p2p orders),\n  // or 0 for limitOrders, so that anyone can be the taker of the Order\n  const nonceAndMeta = (\n    BigInt(takerInNonce) +\n    (BigInt(nonce) << BigInt(160))\n  ).toString(10);\n\n  const makerAsset = assetAddressToUint(_makerAssetAddress, makerAssetType);\n\n  const takerAsset = assetAddressToUint(_takerAssetAddress, takerAssetType);\n\n  const orderNFT: NFTOrderData = {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker: AugustusAddress,\n    makerAmount,\n    takerAmount,\n    makerAssetId,\n    takerAssetId,\n  };\n\n  return {\n    types: { OrderNFT },\n    domain: { name, version, chainId, verifyingContract },\n    data: orderNFT,\n  };\n}\n\n// create a packed number that contains assetAddress and AssetType\nexport function assetAddressToUint(\n  assetAddress: Address,\n  assetType: AssetTypeVariant\n): BigIntAsString {\n  return (BigInt(assetAddress) + (BigInt(assetType) << BigInt(160))).toString(\n    10\n  );\n}\n","import {\n  BaseFetchUrl,\n  baseFetchUrlGetterFactory,\n  BaseFetchUrlInputConstructor,\n  MinFetchUrl,\n} from '../../common/orders/misc';\nimport {\n  assetAddressToUint,\n  BuildNFTOrderDataInput,\n  NFTOrderData,\n} from './buildOrderData';\n\n// any number can be assigned to AssetType enum\n// https://github.com/Microsoft/TypeScript/issues/22311\n// export enum AssetType {\n//   ERC20 = 0,\n//   ERC1155 = 1,\n//   ERC721 = 2,\n// }\n\nexport const AssetType = {\n  ERC20: 0,\n  ERC1155: 1,\n  ERC721: 2,\n} as const;\n\nexport function sanitizeOrderData({\n  nonceAndMeta,\n  expiry,\n  makerAsset: _makerAsset,\n  takerAsset: _takerAsset,\n  maker,\n  taker,\n  makerAmount,\n  takerAmount,\n  makerAssetId,\n  takerAssetId,\n  // asset types provided when Order has them ,e.g. got Order by hash from API\n  makerAssetType,\n  takerAssetType,\n}: NFTOrderData &\n  Partial<Pick<BuildNFTOrderDataInput, 'makerAssetType' | 'takerAssetType'>> &\n  Record<string, any>): NFTOrderData {\n  const makerAsset =\n    makerAssetType !== undefined && _makerAsset.startsWith('0x')\n      ? assetAddressToUint(_makerAsset, makerAssetType)\n      : _makerAsset;\n  const takerAsset =\n    takerAssetType !== undefined && _takerAsset.startsWith('0x')\n      ? assetAddressToUint(_takerAsset, takerAssetType)\n      : _takerAsset;\n\n  return {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker,\n    makerAmount,\n    takerAmount,\n    makerAssetId,\n    takerAssetId,\n  };\n}\n\n/* \nGET\n/nft/orders/:chainId/maker/:walletAddress\n/nft/orders/:chainId/taker/:walletAddress\n/nft/p2p/:chainId/maker/:walletAddress\n/nft/p2p/:chainId/taker/:walletAddress\n*/\nexport type GetOrdersURLs = `${BaseFetchUrl<'nft'>}/${\n  | 'taker'\n  | 'maker'}/${string}`;\n\n/*\nGET\n/nft/order/:orderHash (get you p2p or orders)\n*/\nexport type GetOrderURL = `${MinFetchUrl<'nft'>}/${string}`;\n\n/* \nPOST create order\n/nft/orders/:chainId/\n/nft/p2p/:chainId/\n*/\nexport type PostOrderURLs = BaseFetchUrl<'nft'>;\n\nexport const constructBaseFetchUrlGetter: BaseFetchUrlInputConstructor<'nft'> =\n  baseFetchUrlGetterFactory('nft');\n","import type { WithGasPrice, WithMaxFee } from '../../gas';\nimport type {\n  ConstructFetchInput,\n  Address,\n  FetcherPostInput,\n  PriceString,\n  OptimalRate,\n} from '../../types';\n\nimport { assert } from 'ts-essentials';\nimport { API_URL, SwapSide } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type { OrderData } from '../limitOrders/buildOrder';\nimport { sanitizeOrderData as sanitizeLimitOrderData } from '../limitOrders/helpers/misc';\nimport { sanitizeOrderData as sanitizeNFTOrderData } from '../nftOrders/helpers/misc';\nimport { AssetTypeVariant } from '../nftOrders/helpers/types';\n\nexport interface TransactionParams {\n  to: string;\n  from: string;\n  value: string;\n  data: string;\n  gasPrice: string;\n  gas?: string;\n  chainId: number;\n}\n\nexport type SwappableOrder = OrderData & {\n  permitMakerAsset?: string;\n  signature: string;\n};\n\nexport type SwappableNFTOrder = SwappableOrder & {\n  makerAssetId: string;\n  takerAssetId: string;\n  makerAssetType: AssetTypeVariant;\n  takerAssetType: AssetTypeVariant;\n};\n\n// when priceRoute with side=SELL, slippage can replace destAmount\nexport type TxInputAmountsPartSell = {\n  slippage: number;\n  srcAmount: PriceString;\n  destAmount?: never; // disallowed\n};\n// when priceRoute with side=BUY, slippage can replace srcAmount\nexport type TxInputAmountsPartBuy = {\n  slippage: number;\n  srcAmount?: never; // disallowed\n  destAmount: PriceString;\n};\n// both srcAmount and destAmount can be present in absence of slippage\nexport type TxInputAmountsPartBuyOrSell = {\n  slippage?: never; // disallowed\n  srcAmount: PriceString;\n  destAmount: PriceString;\n};\n\n// more details in the docs https://developers.paraswap.network/api/build-parameters-for-transaction#request-body\nexport type BuildTxInputBase = {\n  srcToken: Address;\n  destToken: Address;\n  userAddress: Address;\n  /** @description Whenever msg.sender (`userAddress`) i.e. address calling the ParaSwap contract is different than the address sending the transaction, `txOrigin` must be passed along with `userAddress` */\n  txOrigin?: string;\n  /** @description used with referral link */\n  referrer?: string;\n  partner?: string;\n  partnerAddress?: string;\n  partnerFeeBps?: number;\n  /** @description If user should receive surplus instead of partner. Default: false */\n  isSurplusToUser?: boolean;\n  /** @description If fees should be sent directly to the partner instead of registering them on FeeClaimer. v6 only. Default: false */\n  isDirectFeeTransfer?: boolean;\n  /** @deprecated Use \"takeSurplus\" instead. Positive slippage goes to user, true by default */\n  positiveSlippageToUser?: boolean;\n  /** @description Set to true to take positive slippage. Works with partnerAddress. Default: false */\n  takeSurplus?: boolean;\n  /** @description Cap the surplus at 1% maximum. Default: true */\n  isCapSurplus?: boolean;\n  receiver?: Address;\n  srcDecimals?: number;\n  destDecimals?: number;\n  permit?: string;\n  deadline?: string;\n};\n\n// for Swap transaction\nexport type BuildSwapTxInput = BuildTxInputBase & {\n  priceRoute: OptimalRate;\n} & (\n    | TxInputAmountsPartSell\n    | TxInputAmountsPartBuy\n    | TxInputAmountsPartBuyOrSell\n  ); // this union doesn't allow to mix srcAmount & destAmount & slippage together\n\n// building block for LimitOrders and NFT Orders swaps\n// can only use priceRoute.side=BUY and related TxInputAmountsPart*\ntype BuildTxInputBaseBUYForOrders<\n  // to Omit extra keys\n  // can't do Omit<> around union, breaks discriminated union\n  K extends keyof TxInputAmountsPartBuy | keyof BuildTxInputBase = never\n> = Omit<BuildTxInputBase, K> &\n  // destAmount is sum(orders[].makerAmount)\n  (| Omit<TxInputAmountsPartBuy, 'destAmount' | K>\n    | Omit<TxInputAmountsPartBuyOrSell, 'destAmount' | K>\n  );\n\n// for LimitOrder Fill, without swap\nexport type BuildLimitOrderTxInput = BuildTxInputBaseBUYForOrders & {\n  orders: SwappableOrder[];\n  srcDecimals: number;\n  destDecimals: number;\n};\n\n// for NFT Order Fill, without swap\nexport type BuildNFTOrderTxInput =\n  // @TODO if NFT can ever be srcToken, change logic\n  //                           for NFT token destDecimals = 0 is acceptable\n  BuildTxInputBaseBUYForOrders<'destDecimals'> & {\n    orders: SwappableNFTOrder[];\n    srcDecimals: number;\n  };\n\nexport interface BuildSwapAndLimitOrderTxInput0\n  // destAmount is sum(orders[].makerAmount)\n  extends Omit<BuildTxInputBase, 'destAmount'> {\n  priceRoute: OptimalRate; // priceRoute.side=BUY\n  orders: SwappableOrder[];\n  destDecimals: number;\n}\n// for Swap + LimitOrder, priceRoute must have side=BUY\nexport type BuildSwapAndLimitOrderTxInput =\n  // destAmount is sum(orders[].makerAmount)\n  BuildTxInputBaseBUYForOrders & {\n    priceRoute: OptimalRate; // priceRoute.side=BUY & priceRoute.contractMethod=simpleBuy\n    orders: SwappableOrder[];\n    destDecimals: number;\n  };\n\n// with slippage for a swap and fill - p2p - order, without to fill a p2p order directly with the intended taker asset\n\n// for Swap + NFT Order, priceRoute must have side=BUY\nexport type BuildSwapAndNFTOrderTxInput =\n  // destAmount is sum(orders[].makerAmount)\n  BuildTxInputBaseBUYForOrders & {\n    priceRoute: OptimalRate; // priceRoute.side=BUY & priceRoute.contractMethod=simpleBuy\n    orders: SwappableNFTOrder[];\n  };\n\nexport type BuildTxInput =\n  | BuildSwapTxInput\n  | BuildLimitOrderTxInput\n  | BuildNFTOrderTxInput\n  | BuildSwapAndLimitOrderTxInput\n  | BuildSwapAndNFTOrderTxInput;\n\nexport type BuildOptionsBase = {\n  /** @description Allows the API to skip performing onchain checks such as balances, allowances, as well as transaction simulations. The response does not contain `gas` parameter when set to `true` */\n  ignoreChecks?: boolean;\n  /** @description Allows the API to skip gas checks. The response does not contain `gas` parameter when set to `true` */\n  ignoreGasEstimate?: boolean;\n  /** @description Allows the API to skip performing onchain allowance checks. */\n  ignoreAllowance?: boolean;\n  /** @description Allows the API to return the contract parameters only. */\n  onlyParams?: boolean;\n};\n\nexport type BuildOptionsWithGasPrice = BuildOptionsBase & Partial<WithGasPrice>;\nexport type BuildOptionsWitWithMaxFee = BuildOptionsBase & Partial<WithMaxFee>;\n\nexport type BuildOptions = BuildOptionsWithGasPrice | BuildOptionsWitWithMaxFee;\n\ntype BuildTx = (\n  params: BuildTxInput,\n  options?: BuildOptions,\n  signal?: AbortSignal\n) => Promise<TransactionParams>;\n\nexport type BuildTxFunctions = {\n  buildTx: BuildTx;\n};\n\ntype SearchStringParams = BuildOptions;\n\nexport const constructBuildTx = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): BuildTxFunctions => {\n  const transactionsURL = `${apiURL}/transactions/${chainId}` as const;\n\n  const buildTx: BuildTx = async (params, options = {}, signal) => {\n    if (\n      'priceRoute' in params &&\n      'destAmount' in params && // isn't provided together with `orders`\n      !('orders' in params) // when present, destAmount becomes sum(orders[].makerAmount)\n    ) {\n      const {\n        priceRoute,\n        priceRoute: { side },\n      } = params;\n      const AmountMismatchError =\n        side === SwapSide.SELL\n          ? 'Source Amount Mismatch'\n          : 'Destination Amount Mismatch';\n\n      // user provides srcAmount or slippage but not both. so we only validate accordingly.\n      assert(\n        areAmountsCorrect({\n          queryParams: params,\n          side,\n          priceRoute,\n        }),\n        AmountMismatchError\n      );\n    }\n\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const search = constructSearchString<SearchStringParams>(options);\n\n    const fetchURL = `${transactionsURL}/${search}` as const;\n\n    const sanitizedParams =\n      'orders' in params && params.orders.length > 0\n        ? {\n            ...params,\n            //  make sure we don't pass more with orders than API expects\n            orders: params.orders.map((order) => {\n              const sanitizedOrderData =\n                'makerAssetId' in order\n                  ? sanitizeNFTOrderData(order) // assetType is provided here, because Order.*Asset may be address\n                  : // if Order received from API by hash\n                    sanitizeLimitOrderData(order);\n\n              const sanitizedOrder: SwappableOrder = {\n                ...sanitizedOrderData,\n                signature: order.signature,\n              };\n\n              if (order.permitMakerAsset) {\n                sanitizedOrder.permitMakerAsset = order.permitMakerAsset;\n              }\n\n              return sanitizedOrder;\n            }),\n          }\n        : params;\n\n    const takeSurplus =\n      params.takeSurplus ??\n      (params.positiveSlippageToUser !== undefined\n        ? !params.positiveSlippageToUser\n        : undefined);\n\n    if ('positiveSlippageToUser' in sanitizedParams) {\n      // positiveSlippageToUser & takeSurplus together will Error in API\n      delete sanitizedParams.positiveSlippageToUser;\n    }\n    if (takeSurplus !== undefined) {\n      sanitizedParams.takeSurplus = takeSurplus;\n    }\n\n    const fetchParams: FetcherPostInput = {\n      url: fetchURL,\n      method: 'POST',\n      data: sanitizedParams,\n      signal,\n    };\n\n    const builtTx = await fetcher<TransactionParams>(fetchParams);\n\n    return builtTx;\n  };\n\n  return { buildTx };\n};\n\ninterface AreAmountsCorrectInput {\n  queryParams: { srcAmount?: string; destAmount?: string; slippage?: number };\n  side: SwapSide;\n  priceRoute: OptimalRate;\n}\n\nfunction areAmountsCorrect({\n  queryParams,\n  side,\n  priceRoute,\n}: AreAmountsCorrectInput): boolean {\n  // return early after a simpler check if the user was swapping before filling\n  if (queryParams.slippage) {\n    return (\n      (side === SwapSide.BUY &&\n        queryParams.destAmount === priceRoute.destAmount) ||\n      (side === SwapSide.SELL && queryParams.srcAmount === priceRoute.srcAmount)\n    );\n  }\n\n  // provided amounts match the previously queried price route\n  const [inputAmount, priceRouteAmount] =\n    side === SwapSide.SELL\n      ? [queryParams.srcAmount, priceRoute.srcAmount]\n      : [queryParams.destAmount, priceRoute.destAmount];\n\n  return inputAmount === priceRouteAmount;\n}\n","import { getRandomInt } from '../../../helpers/misc';\nimport type { Address, ParaSwapVersionUnion } from '../../../types';\nimport {\n  Domain,\n  name,\n  version,\n  ZERO_ADDRESS,\n} from '../../common/orders/buildOrderData';\n\nconst Order = [\n  { name: 'nonceAndMeta', type: 'uint256' },\n  { name: 'expiry', type: 'uint128' },\n  { name: 'makerAsset', type: 'address' },\n  { name: 'takerAsset', type: 'address' },\n  { name: 'maker', type: 'address' },\n  { name: 'taker', type: 'address' },\n  { name: 'makerAmount', type: 'uint256' },\n  { name: 'takerAmount', type: 'uint256' },\n];\n\nexport interface BuildOrderDataInput {\n  chainId: number;\n  verifyingContract: Address;\n  nonce?: number;\n  expiry: number;\n  makerAsset: Address;\n  takerAsset: Address;\n  makerAmount: string;\n  takerAmount: string;\n  maker: Address;\n  // OrderData.taker must be Augustus (or other Executor) for p2p limitOrders to involve swap through Augustus\n  /** @description actual user taker which will go into nonceAndMeta */\n  taker?: Address;\n  /** @description contract executor (Augustus or similar) that is allowed to execute the order, gois in Order.taker */\n  contractTaker?: Address;\n\n  AugustusAddress: Address;\n  AppVersion: ParaSwapVersionUnion;\n}\n\nexport type SignableOrderData = {\n  types: { Order: typeof Order };\n  domain: Domain;\n  data: OrderData;\n};\n\nexport type OrderData = {\n  nonceAndMeta: string;\n  expiry: number;\n  makerAsset: string;\n  takerAsset: string;\n  maker: string;\n  taker: string;\n  makerAmount: string;\n  takerAmount: string;\n};\n\nexport function buildOrderData({\n  chainId,\n  verifyingContract,\n  nonce = getRandomInt(),\n  expiry,\n  makerAsset,\n  takerAsset,\n  makerAmount,\n  takerAmount,\n  maker,\n  AugustusAddress,\n  // if taker is specified -- p2p order for that taker only to fill through Augustus (v5) or direcly (v6)-- taker = Augustus | _taker, takerInNonce = _taker\n  // if taker is not specified -- limitOrder for anyone to fill through Augustus or not -- taker = Zero, takerInNonce = Zero\n  taker: takerInNonce = ZERO_ADDRESS,\n  // if given, overrides the above choices made based on `taker`\n  contractTaker,\n  // for v6 only support taker=_taker for OTC orders\n  AppVersion,\n}: BuildOrderDataInput): SignableOrderData {\n  // first 160 bits is taker address (for p2p orders),\n  // or 0 for limitOrders, so that anyone can be the taker of the Order\n  const nonceAndMeta = (\n    BigInt(takerInNonce) +\n    (BigInt(nonce) << BigInt(160))\n  ).toString(10);\n\n  let taker: string;\n  // contractTaker overrides always\n  if (contractTaker) {\n    taker = contractTaker;\n  } else if (takerInNonce === ZERO_ADDRESS) {\n    // no takerInNonce -> not p2p order -> allow anyone to fill (not only Augustus)\n    taker = ZERO_ADDRESS;\n  } else {\n    // otherwise for p2p order ->\n    if (AppVersion.startsWith('6.')) {\n      //support 6.1+ versions\n\n      // limit taker to EOA for v6 version (no Arbitrary Token Swaps + OTC Fill, or OTC Fill through AugustusSwapper)\n      taker = takerInNonce;\n    } else {\n      // on v5\n      // -> fill through Augustus only\n      taker = AugustusAddress;\n    }\n  }\n\n  const order: OrderData = {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker,\n    makerAmount,\n    takerAmount,\n  };\n\n  return {\n    types: { Order },\n    domain: { name, version, chainId, verifyingContract },\n    data: order,\n  };\n}\n","import { DEFAULT_VERSION } from '../../constants';\nimport type { ConstructFetchInput } from '../../types';\nimport { constructGetSpender } from '../swap/spender';\nimport {\n  buildOrderData,\n  BuildOrderDataInput,\n  SignableOrderData,\n} from './helpers/buildOrderData';\nexport * from './helpers/buildOrderData';\n\nexport type BuildLimitOrderInput = Omit<\n  BuildOrderDataInput,\n  'chainId' | 'verifyingContract' | 'AugustusAddress' | 'AppVersion'\n>;\n\ntype BuildLimitOrder = (\n  buildLimitOrderParams: BuildLimitOrderInput,\n  signal?: AbortSignal\n) => Promise<SignableOrderData>;\n\nexport type BuildLimitOrderFunctions = {\n  /** @description Build Orders that will be excuted through AugustusSwapper */\n  buildLimitOrder: BuildLimitOrder;\n};\n\nexport const constructBuildLimitOrder = (\n  options: ConstructFetchInput\n): BuildLimitOrderFunctions => {\n  const { chainId } = options;\n\n  // getContracts is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getContracts } = constructGetSpender(options);\n\n  const buildLimitOrder: BuildLimitOrder = async (\n    buildLimitOrderParams,\n    signal\n  ) => {\n    const { AugustusSwapper: AugustusAddress, AugustusRFQ: verifyingContract } =\n      await getContracts(signal);\n\n    const AppVersion = options.version ?? DEFAULT_VERSION;\n\n    return buildOrderData({\n      ...buildLimitOrderParams,\n      chainId,\n      verifyingContract,\n      AugustusAddress,\n      AppVersion,\n    });\n  };\n\n  return {\n    buildLimitOrder,\n  };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport type { SignableOrderData } from './buildOrder';\nimport { sanitizeOrderData } from './helpers/misc';\n\nexport type SignLimitOrderFunctions = {\n  signLimitOrder: (signableOrderData: SignableOrderData) => Promise<string>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructSignLimitOrder = (\n  options: Pick<\n    ConstructProviderFetchInput<any, 'signTypedDataCall'>,\n    'contractCaller'\n  >\n): SignLimitOrderFunctions => {\n  const signLimitOrder: SignLimitOrderFunctions['signLimitOrder'] = (\n    typedData\n  ) => {\n    // types allow to pass OrderData & extra_stuff, but tx will break like that\n    const typedDataOnly: SignableOrderData = {\n      ...typedData,\n      data: sanitizeOrderData(typedData.data),\n    };\n    return options.contractCaller.signTypedDataCall(typedDataOnly);\n  };\n\n  return { signLimitOrder };\n};\n","import type { ExtractAbiMethodNames } from '../../helpers/misc';\nimport type { ConstructProviderFetchInput, TxSendOverrides } from '../../types';\nimport { constructGetSpender } from '../swap/spender';\n\ntype CancelOrder<T> = (\n  orderHash: string,\n  overrides?: TxSendOverrides,\n  signal?: AbortSignal\n) => Promise<T>;\n\ntype CancelOrderBulk<T> = (\n  orderHashes: string[],\n  overrides?: TxSendOverrides,\n  signal?: AbortSignal\n) => Promise<T>;\n\nexport type CancelLimitOrderFunctions<T> = {\n  cancelLimitOrder: CancelOrder<T>;\n  cancelLimitOrderBulk: CancelOrderBulk<T>;\n};\n\n// much smaller than the whole AugustusRFQ_ABI\nconst MinAugustusRFQAbi = [\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: 'orderHash',\n        type: 'bytes32',\n      },\n    ],\n    name: 'cancelOrder',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32[]',\n        name: 'orderHashes',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'cancelOrders',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype AvailableMethods = ExtractAbiMethodNames<typeof MinAugustusRFQAbi>;\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructCancelLimitOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): CancelLimitOrderFunctions<T> => {\n  // getAugustusRFQ is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getAugustusRFQ } = constructGetSpender(options);\n\n  const cancelLimitOrder: CancelOrder<T> = async (\n    orderHash,\n    overrides = {},\n    signal\n  ) => {\n    const verifyingContract = await getAugustusRFQ(signal);\n\n    const res = await options.contractCaller.transactCall<AvailableMethods>({\n      // @CHECK if verifyingContract is the one we need to approve\n      // maybe a Proxy in-between\n      address: verifyingContract,\n      abi: MinAugustusRFQAbi,\n      contractMethod: 'cancelOrder',\n      args: [orderHash],\n      overrides,\n    });\n\n    return res;\n  };\n\n  const cancelLimitOrderBulk: CancelOrderBulk<T> = async (\n    orderHashes,\n    overrides = {},\n    signal\n  ) => {\n    const verifyingContract = await getAugustusRFQ(signal);\n\n    const res = await options.contractCaller.transactCall<AvailableMethods>({\n      // @CHECK if verifyingContract is the one we need to approve\n      // maybe a Proxy in-between\n      address: verifyingContract,\n      abi: MinAugustusRFQAbi,\n      contractMethod: 'cancelOrders',\n      args: [orderHashes],\n      overrides,\n    });\n\n    return res;\n  };\n\n  return {\n    cancelLimitOrder,\n    cancelLimitOrderBulk,\n  };\n};\n","import type { ExtractAbiMethodNames } from '../../helpers/misc';\nimport type { ConstructProviderFetchInput, TxSendOverrides } from '../../types';\nimport type { OrderData } from './buildOrder';\nimport { constructGetSpender } from '../swap/spender';\nimport { sanitizeOrderData } from './helpers/misc';\n\nexport type FillOrderDirectlyFunctions<T> = {\n  fillOrderDirectly: FillOrderDirectly<T>;\n};\n\nexport type FillOrderDirectly<T> = (\n  order: OrderData,\n  signature: string,\n  overrides?: TxSendOverrides,\n  signal?: AbortSignal\n) => Promise<T>;\n\n// much smaller than the whole AugustusRFQ_ABI\nconst MinAugustusRFQAbi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'nonceAndMeta',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint128',\n            name: 'expiry',\n            type: 'uint128',\n          },\n          {\n            internalType: 'address',\n            name: 'makerAsset',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'takerAsset',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'maker',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'taker',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'makerAmount',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'takerAmount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct AugustusRFQ.Order',\n        name: 'order',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'signature',\n        type: 'bytes',\n      },\n    ],\n    name: 'fillOrder',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype FillOrderMethods = ExtractAbiMethodNames<typeof MinAugustusRFQAbi>;\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport function constructFillOrderDirectly<T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): FillOrderDirectlyFunctions<T> {\n  // getAugustusRFQ is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getAugustusRFQ } = constructGetSpender(options);\n\n  const fillOrderDirectly: FillOrderDirectly<T> = async (\n    order,\n    signature,\n    overrides = {},\n    signal\n  ) => {\n    const AugustusRFQ = await getAugustusRFQ(signal);\n\n    const sanitizedOrder = sanitizeOrderData(order);\n\n    const res = await options.contractCaller.transactCall<FillOrderMethods>({\n      address: AugustusRFQ,\n      abi: MinAugustusRFQAbi,\n      contractMethod: 'fillOrder',\n      args: [sanitizedOrder, signature],\n      overrides,\n    });\n\n    return res;\n  };\n\n  return { fillOrderDirectly };\n}\n","// @TODO getOrder, getOrders from API\n// onchain from contract can't distinguish between filled or cancelled\nimport { API_URL } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type { Address, ConstructFetchInput } from '../../types';\nimport {\n  constructBaseFetchUrlGetter,\n  GetOrdersURLs,\n  GetOrderURL,\n  GetRequiredAllowanceURL as GetRequiredBalanceURL,\n} from './helpers/misc';\nimport type {\n  LimitOrderFromApi,\n  LimitOrdersApiResponse,\n  LimitOrderType,\n} from './helpers/types';\n\ntype PaginationParams = {\n  limit?: number;\n  offset?: number;\n  hideSmallBalances?: boolean;\n  orderBy?: 'createdAt' | 'updatedAt' | 'expiry';\n};\n\n//                     get orders by `maker` or `taker`\nexport type LimitOrdersUserParams = (\n  | { maker: Address; type: LimitOrderType }\n  | { taker: Address; type: LimitOrderType }\n) &\n  PaginationParams;\n\nexport type GetRequiredAllowanceParams = {\n  maker: Address;\n  token?: Address;\n};\n\ntype GetLimitOrderByHash = (\n  orderHash: string,\n  signal?: AbortSignal\n) => Promise<LimitOrderFromApi>;\ntype GetLimitOrders = (\n  userParams: LimitOrdersUserParams,\n  signal?: AbortSignal\n) => Promise<LimitOrdersApiResponse>;\n\ntype GetRequiredBalance = (\n  userParams: GetRequiredAllowanceParams,\n  singal?: AbortSignal\n) => Promise<Record<string, string>>;\n\nexport type GetLimitOrdersFunctions = {\n  getLimitOrders: GetLimitOrders;\n  getLimitOrderByHash: GetLimitOrderByHash;\n  /**\n   * Gets fillableBalance for tokens from user's active orders.\n   * User needs to have enough balance & allowance to cover active orders before creating new orders.\n   * @param userParams - parameters to get allowance for active orders\n   * @param {string} userParams.maker - user to get required allowances for\n   * @param {string=} userParams.token - if given `token`, the mapping will contain that token address only\n   * @param {AbortSignal=} signal - AbortSignal passed to fetcher\n   * @returns `{Lowercase<Address> => wei number as string}` mapping of token to fillableBalance\n   */\n  getRequiredBalance: GetRequiredBalance;\n};\n\nexport const constructGetLimitOrders = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetLimitOrdersFunctions => {\n  const getBaseFetchURLByEntityType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const getLimitOrders: GetLimitOrders = async (userParams, signal) => {\n    const baseFetchURL = getBaseFetchURLByEntityType(userParams.type);\n    const userURL =\n      'maker' in userParams\n        ? (`maker/${userParams.maker}` as const)\n        : (`taker/${userParams.taker}` as const);\n\n    const { offset, limit, hideSmallBalances, orderBy } = userParams;\n    const search = constructSearchString<PaginationParams>({\n      offset,\n      limit,\n      hideSmallBalances,\n      orderBy,\n    });\n\n    const fetchURL = `${baseFetchURL}/${userURL}${search}` as const;\n\n    const response = await fetcher<LimitOrdersApiResponse, GetOrdersURLs>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    // without any extra calls, return  what API returns\n    return response;\n  };\n\n  const getRequiredBalance: GetRequiredBalance = async (userParams, signal) => {\n    const baseFetchURL = getBaseFetchURLByEntityType('fillablebalance');\n    const userURL = `${baseFetchURL}/${userParams.maker}` as const;\n    const fetchURL = userParams.token\n      ? (`${userURL}/${userParams.token}` as const)\n      : userURL;\n\n    const response = await fetcher<\n      Record<string, string>,\n      GetRequiredBalanceURL\n    >({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    // without any extra calls, return  what API returns\n    return response;\n  };\n\n  const getLimitOrderByHash: GetLimitOrderByHash = async (\n    orderHash,\n    signal\n  ) => {\n    const baseFetchURL = getBaseFetchURLByEntityType();\n    const fetchURL = `${baseFetchURL}/${orderHash}` as const;\n\n    const order = await fetcher<LimitOrderFromApi, GetOrderURL>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    return order;\n  };\n\n  return {\n    getLimitOrders,\n    getLimitOrderByHash,\n    getRequiredBalance,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type { ConstructFetchInput } from '../../types';\nimport { constructBaseFetchUrlGetter, PostOrderURLs } from './helpers/misc';\nimport type {\n  LimitOrderApiResponse,\n  LimitOrderToSend,\n  LimitOrderFromApi,\n  LimitOrderType,\n} from './helpers/types';\n\ntype PostLimitOrder = (\n  limitOrderWithSignatureAndPermit: LimitOrderToSend,\n  signal?: AbortSignal\n) => Promise<LimitOrderFromApi>;\n\nexport type PostLimitOrderFunctions = {\n  postLimitOrder: PostLimitOrder;\n  postP2POrder: PostLimitOrder;\n};\n\nexport const constructPostLimitOrder = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): PostLimitOrderFunctions => {\n  const getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const postTypedOrder = async (\n    limitOrderWithSignatureAndPermit: LimitOrderToSend,\n    type: LimitOrderType,\n    signal?: AbortSignal\n  ): Promise<LimitOrderFromApi> => {\n    const fetchURL = getBaseFetchURLByOrderType(type);\n\n    const { order: newOrder } = await fetcher<\n      LimitOrderApiResponse,\n      PostOrderURLs\n    >({\n      url: fetchURL,\n      method: 'POST',\n      data: limitOrderWithSignatureAndPermit,\n      signal,\n    });\n\n    return newOrder;\n  };\n\n  const postLimitOrder: PostLimitOrder = (\n    limitOrderWithSignatureAndPermit,\n    signal\n  ) => {\n    return postTypedOrder(limitOrderWithSignatureAndPermit, 'LIMIT', signal);\n  };\n\n  const postP2POrder: PostLimitOrder = (\n    limitOrderWithSignatureAndPermit,\n    signal\n  ) => {\n    return postTypedOrder(limitOrderWithSignatureAndPermit, 'P2P', signal);\n  };\n\n  return { postLimitOrder, postP2POrder };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport { ApproveToken, approveTokenMethodFactory } from '../../helpers/approve';\nimport { constructApproveToken } from '../swap/approve';\nimport { constructGetSpender } from '../swap/spender';\n\nexport type ApproveTokenForLimitOrderFunctions<T> = {\n  /** @description approving AugustusRFQ as spender for makerAsset */\n  approveMakerTokenForLimitOrder: ApproveToken<T>;\n  /** @description approving AugustusSwapper as spender for takerAsset for Limit Orders that will be executed through it */\n  approveTakerTokenForLimitOrder: ApproveToken<T>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructApproveTokenForLimitOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): ApproveTokenForLimitOrderFunctions<T> => {\n  // getAugustusRFQ is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getAugustusRFQ } = constructGetSpender(options);\n\n  const approveMakerTokenForLimitOrder: ApproveToken<T> =\n    approveTokenMethodFactory<T>(options.contractCaller, getAugustusRFQ);\n\n  // approving TokenTransaferProxy as for the swap\n  const { approveToken: approveTakerTokenForLimitOrder } =\n    constructApproveToken(options);\n\n  return {\n    approveMakerTokenForLimitOrder,\n    approveTakerTokenForLimitOrder,\n  };\n};\n","import type { ConstructFetchInput } from '../../types';\nimport { constructGetSpender, GetSpender } from '../swap/spender';\n\nexport type GetLimitOrdersContractFunctions = {\n  getLimitOrdersContract: GetSpender;\n  getTokenTransferProxy: GetSpender;\n};\n\nexport const constructGetLimitOrdersContract = (\n  options: ConstructFetchInput\n): GetLimitOrdersContractFunctions => {\n  // analogous to getSpender() but for Limit Orders Contract = AugustusRFQ\n\n  const {\n    getSpender: getTokenTransferProxy,\n    getAugustusRFQ: getLimitOrdersContract,\n  } = constructGetSpender(options);\n\n  return { getLimitOrdersContract, getTokenTransferProxy };\n};\n","import type { ConstructFetchInput, OptimalRate } from '../../types';\n\nimport { assert } from 'ts-essentials';\nimport {\n  API_URL,\n  SwapSide,\n  ContractMethod,\n  DEFAULT_VERSION,\n} from '../../constants';\nimport {\n  BuildLimitOrderTxInput,\n  BuildOptions,\n  BuildSwapAndLimitOrderTxInput,\n  TransactionParams,\n  constructBuildTx,\n} from '../swap/transaction';\nimport { constructGetRate, GetRateInput, RateOptions } from '../swap/rates';\nimport type { OrderData } from './buildOrder';\nimport { isFilledArray } from '../../helpers/misc';\n\ntype MinBuildSwapAndLimitOrderTxInput = Omit<\n  // these are derived from `orders`\n  BuildSwapAndLimitOrderTxInput,\n  'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'\n>;\n\ntype BuildSwapAndLimitOrdersTx = (\n  params: MinBuildSwapAndLimitOrderTxInput,\n  options?: BuildOptions,\n  signal?: AbortSignal\n) => Promise<TransactionParams>;\n\ntype MinBuildLimitOrderTxInput = Omit<\n  BuildLimitOrderTxInput,\n  // these are derived from `orders`\n  'srcToken' | 'srcAmount' | 'destToken' | 'slippage'\n  // `slippage` doesn't participate as we derive `srcAmount` already\n>;\n\ntype BuildLimitOrdersTx = (\n  params: MinBuildLimitOrderTxInput,\n  options?: BuildOptions,\n  signal?: AbortSignal\n) => Promise<TransactionParams>;\n\nexport type BuildLimitOrdersTxFunctions = {\n  getLimitOrdersRate: GetLimitOrdersRate;\n  buildLimitOrderTx: BuildLimitOrdersTx;\n  buildSwapAndLimitOrderTx: BuildSwapAndLimitOrdersTx;\n};\n\ntype GetLimitOrdersRate = (\n  // `amount`, if given, must equal the total of the orders' `takerAmounts`\n  options: Omit<GetRateInput, 'amount' | 'side'> & { amount?: string },\n  orders: CheckableOrderData[],\n  signal?: AbortSignal\n) => Promise<OptimalRate>;\n\nexport const constructBuildLimitOrderTx = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): BuildLimitOrdersTxFunctions => {\n  const { buildTx: buildSwapTx } = constructBuildTx({\n    apiURL,\n    chainId,\n    fetcher,\n    version,\n  });\n\n  const { getRate: getSwapAndLimitOrderRate } = constructGetRate({\n    apiURL,\n    version,\n    chainId,\n    fetcher,\n  });\n\n  //  returns priceRoute that would allow to swap from srcToken to destToken(=order.takerAsset) followed by filling limit orders\n  const getLimitOrdersRate: GetLimitOrdersRate = async (\n    { srcToken, destToken, amount, options: _options = {}, ...rest },\n    orders,\n    signal\n  ) => {\n    assert(orders.length > 0, 'must pass at least 1 order');\n\n    const { totalTakerAmount, takerAsset } = checkAndParseOrders(orders);\n    assert(\n      takerAsset.toLowerCase() === destToken.toLowerCase(),\n      'All orders must have the same takerAsset as destToken'\n    );\n\n    const takerAmountString = totalTakerAmount.toString(10);\n\n    if (amount) {\n      assert(\n        amount === takerAmountString,\n        \"`amount` must equal the total of the orders' `takerAmounts`\"\n      );\n    }\n\n    // The pricing must use includeContractMethods=simpleBuy and side=BUY\n    const options: RateOptions = {\n      ..._options,\n      includeContractMethods: [ContractMethod.simpleBuy],\n    };\n\n    const side = SwapSide.BUY;\n\n    const rateInput: GetRateInput = {\n      ...rest,\n      srcToken,\n      destToken,\n      amount: takerAmountString,\n      side,\n      options,\n    };\n\n    // priceRoute\n    const optimalRate = await getSwapAndLimitOrderRate(rateInput, signal);\n    return optimalRate;\n  };\n\n  // derive srcToken, destToken and srcAmount from orders[]\n  const buildLimitOrderTx: BuildLimitOrdersTx = (params, options, signal) => {\n    const { makerAsset, takerAsset, totalTakerAmount } = checkAndParseOrders(\n      params.orders\n    );\n\n    const fillParams: BuildLimitOrderTxInput = {\n      ...params,\n      // taker supplies takerAsset\n      srcToken: takerAsset,\n      // no `slippage` in `params`\n      srcAmount: totalTakerAmount.toString(10),\n      // taker gets makerAsset in the end\n      destToken: makerAsset,\n    };\n\n    return buildSwapTx(fillParams, options, signal);\n  };\n\n  const buildSwapAndLimitOrderTx: BuildSwapAndLimitOrdersTx = (\n    params,\n    options,\n    signal\n  ) => {\n    const { makerAsset } = checkAndParseOrders(params.orders);\n\n    const fillParams: BuildSwapAndLimitOrderTxInput = {\n      ...params,\n      // taker supplies srcToken\n      srcToken: params.priceRoute.srcToken,\n      // which is swapped for makerAsset, that would go towards filling the orders\n      destToken: makerAsset,\n      destDecimals: params.priceRoute.destDecimals,\n      // one or the other\n      ...(params.slippage\n        ? { slippage: params.slippage }\n        : //                                        may sneak in as part of `params`\n          { srcAmount: params.priceRoute.srcAmount, slippage: undefined }),\n    };\n\n    return buildSwapTx(fillParams, options, signal);\n  };\n\n  return {\n    getLimitOrdersRate,\n    buildLimitOrderTx,\n    buildSwapAndLimitOrderTx,\n  };\n};\n\ntype CheckAndParseOrdersResult = Omit<CheckableOrderData, 'takerAmount'> & {\n  totalTakerAmount: bigint;\n};\n\ntype CheckableOrderData = Pick<\n  OrderData,\n  'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'\n> & { taker?: OrderData['taker'] };\n\nfunction checkAndParseOrders(\n  orders: CheckableOrderData[]\n): CheckAndParseOrdersResult {\n  assert(isFilledArray(orders), 'must pass at least 1 order');\n\n  const { takerAssetsSet, makerAssetsSet, totalTakerAmount } = orders.reduce<\n    Record<'takerAssetsSet' | 'makerAssetsSet', Set<string>> & {\n      totalTakerAmount: bigint;\n    }\n  >(\n    (accum, order) => {\n      accum.takerAssetsSet.add(order.takerAsset.toLowerCase());\n      accum.makerAssetsSet.add(order.makerAsset.toLowerCase());\n\n      accum.totalTakerAmount =\n        accum.totalTakerAmount + BigInt(order.takerAmount);\n      return accum;\n    },\n    {\n      takerAssetsSet: new Set(),\n      makerAssetsSet: new Set(),\n      totalTakerAmount: BigInt(0),\n    }\n  );\n\n  assert(\n    takerAssetsSet.size === 1,\n    'All orders must have the same takerAsset as destToken'\n  );\n  assert(makerAssetsSet.size === 1, 'All orders must have the same makerAsset');\n\n  const [{ maker, taker, makerAsset, takerAsset }] = orders;\n\n  return {\n    totalTakerAmount,\n    maker,\n    taker,\n    makerAsset,\n    takerAsset,\n  };\n}\n","import type { ConstructFetchInput } from '../../types';\nimport { constructGetSpender } from '../swap/spender';\nimport {\n  buildOrderData,\n  BuildNFTOrderDataInput,\n  SignableNFTOrderData,\n} from './helpers/buildOrderData';\nexport * from './helpers/buildOrderData';\n\nexport type BuildNFTOrderInput = Omit<\n  BuildNFTOrderDataInput,\n  'chainId' | 'verifyingContract' | 'AugustusAddress'\n>;\n\ntype BuildNFTOrder = (\n  buildNFTOrderParams: BuildNFTOrderInput,\n  signal?: AbortSignal\n) => Promise<SignableNFTOrderData>;\n\nexport type BuildNFTOrderFunctions = {\n  /** @description Build Orders that will be excuted through AugustusSwapper */\n  buildNFTOrder: BuildNFTOrder;\n};\n\nexport const constructBuildNFTOrder = (\n  options: ConstructFetchInput\n): BuildNFTOrderFunctions => {\n  const { chainId } = options;\n\n  // getContracts is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getContracts } = constructGetSpender(options);\n\n  const buildNFTOrder: BuildNFTOrder = async (buildNFTOrderParams, signal) => {\n    const { AugustusSwapper: AugustusAddress, AugustusRFQ: verifyingContract } =\n      await getContracts(signal);\n\n    return buildOrderData({\n      ...buildNFTOrderParams,\n      chainId,\n      verifyingContract,\n      AugustusAddress,\n    });\n  };\n\n  return {\n    buildNFTOrder,\n  };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport type { SignableNFTOrderData } from './buildOrder';\nimport { sanitizeOrderData } from './helpers/misc';\n\nexport type SignNFTOrderFunctions = {\n  signNFTOrder: (signableOrderData: SignableNFTOrderData) => Promise<string>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructSignNFTOrder = (\n  options: Pick<\n    ConstructProviderFetchInput<any, 'signTypedDataCall'>,\n    'contractCaller'\n  >\n): SignNFTOrderFunctions => {\n  const signNFTOrder: SignNFTOrderFunctions['signNFTOrder'] = (typedData) => {\n    // types allow to pass OrderData & extra_stuff, but tx will break like that\n    const typedDataOnly: SignableNFTOrderData = {\n      ...typedData,\n      // here assetType isn't provided, SignableData must already have corrent BigIntAsString\n      // @TODO consider using `template_${types}` for Address, likely bad idea when considering 3rd-party code\n      data: sanitizeOrderData(typedData.data),\n    };\n    return options.contractCaller.signTypedDataCall(typedDataOnly);\n  };\n\n  return { signNFTOrder };\n};\n","import type { ConstructProviderFetchInput, TxSendOverrides } from '../../types';\nimport { constructCancelLimitOrder } from '../limitOrders/cancelOrder';\n\ntype CancelOrder<T> = (\n  orderHash: string,\n  overrides?: TxSendOverrides\n) => Promise<T>;\n\ntype CancelOrderBulk<T> = (\n  orderHashes: string[],\n  overrides?: TxSendOverrides\n) => Promise<T>;\n\nexport type CancelNFTOrderFunctions<T> = {\n  cancelNFTOrder: CancelOrder<T>;\n  cancelNFTOrderBulk: CancelOrderBulk<T>;\n};\n\n// should work the same as for LimitOrders\nexport const constructCancelNFTOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): CancelNFTOrderFunctions<T> => {\n  const { cancelLimitOrder, cancelLimitOrderBulk } =\n    constructCancelLimitOrder(options);\n  return {\n    cancelNFTOrder: cancelLimitOrder,\n    cancelNFTOrderBulk: cancelLimitOrderBulk,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type { Address, ConstructFetchInput } from '../../types';\nimport {\n  constructBaseFetchUrlGetter,\n  GetOrdersURLs,\n  GetOrderURL,\n} from './helpers/misc';\nimport type {\n  NFTOrderFromAPI,\n  NFTOrdersApiResponse,\n  NFTOrderType,\n} from './helpers/types';\n\n//                     get orders by `maker` or `taker`\nexport type NFTOrdersUserParams =\n  | { maker: Address; type: NFTOrderType }\n  | { taker: Address; type: NFTOrderType };\ntype GetNFTOrderByHash = (\n  orderHash: string,\n  signal?: AbortSignal\n) => Promise<NFTOrderFromAPI>;\ntype GetNFTOrders = (\n  userParams: NFTOrdersUserParams,\n  signal?: AbortSignal\n) => Promise<NFTOrdersApiResponse>;\n\nexport type GetNFTOrdersFunctions = {\n  getNFTOrders: GetNFTOrders;\n  getNFTOrderByHash: GetNFTOrderByHash;\n};\n\nexport const constructGetNFTOrders = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetNFTOrdersFunctions => {\n  const getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const getNFTOrders: GetNFTOrders = async (userParams, signal) => {\n    const baseFetchURL = getBaseFetchURLByOrderType(userParams.type);\n    const userURL =\n      'maker' in userParams\n        ? (`maker/${userParams.maker}` as const)\n        : (`taker/${userParams.taker}` as const);\n    const fetchURL = `${baseFetchURL}/${userURL}` as const;\n\n    const response = await fetcher<NFTOrdersApiResponse, GetOrdersURLs>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    // without any extra calls, return  what API returns\n    return response;\n  };\n\n  const getNFTOrderByHash: GetNFTOrderByHash = async (orderHash, signal) => {\n    const baseFetchURL = getBaseFetchURLByOrderType();\n    const fetchURL = `${baseFetchURL}/${orderHash}` as const;\n\n    const order = await fetcher<NFTOrderFromAPI, GetOrderURL>({\n      url: fetchURL,\n      method: 'GET',\n      signal,\n    });\n\n    return order;\n  };\n\n  return {\n    getNFTOrders,\n    getNFTOrderByHash,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type { ConstructFetchInput } from '../../types';\nimport { constructBaseFetchUrlGetter, PostOrderURLs } from './helpers/misc';\nimport type {\n  NFTOrderToSend,\n  NFTOrderType,\n  NFTOrderFromAPI,\n  NFTOrderApiResponse,\n} from './helpers/types';\n\ntype PostNFTOrder = (\n  NFTOrderWithSignatureAndPermit: NFTOrderToSend,\n  signal?: AbortSignal\n) => Promise<NFTOrderFromAPI>;\n\nexport type PostNFTOrderFunctions = {\n  postNFTLimitOrder: PostNFTOrder;\n  postNFTP2POrder: PostNFTOrder;\n};\n\nexport const constructPostNFTOrder = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): PostNFTOrderFunctions => {\n  const getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const postTypedOrder = async (\n    NFTOrderWithSignatureAndPermit: NFTOrderToSend,\n    type: NFTOrderType,\n    signal?: AbortSignal\n  ): Promise<NFTOrderFromAPI> => {\n    const fetchURL = getBaseFetchURLByOrderType(type);\n\n    // @TODO check API return matches\n    const { order: newOrder } = await fetcher<\n      NFTOrderApiResponse,\n      PostOrderURLs\n    >({\n      url: fetchURL,\n      method: 'POST',\n      data: NFTOrderWithSignatureAndPermit,\n      signal,\n    });\n\n    return { ...newOrder };\n  };\n\n  const postNFTLimitOrder: PostNFTOrder = (\n    NFTOrderWithSignatureAndPermit,\n    signal\n  ) => {\n    return postTypedOrder(NFTOrderWithSignatureAndPermit, 'LIMIT', signal);\n  };\n\n  const postNFTP2POrder: PostNFTOrder = (\n    NFTOrderWithSignatureAndPermit,\n    signal\n  ) => {\n    return postTypedOrder(NFTOrderWithSignatureAndPermit, 'P2P', signal);\n  };\n\n  return { postNFTLimitOrder, postNFTP2POrder };\n};\n","import type { ConstructFetchInput } from '../../types';\nimport { constructGetSpender, GetSpender } from '../swap/spender';\n\nexport type GetNFTOrdersContractFunctions = {\n  getNFTOrdersContract: GetSpender;\n  getTokenTransferProxy: GetSpender;\n};\n\n// should work the same as LimitOrders\nexport const constructGetNFTOrdersContract = (\n  options: ConstructFetchInput\n): GetNFTOrdersContractFunctions => {\n  // analogous to getSpender() but for Limit Orders Contract = AugustusRFQ\n\n  const {\n    getSpender: getTokenTransferProxy,\n    getAugustusRFQ: getNFTOrdersContract,\n  } = constructGetSpender(options);\n\n  return {\n    getNFTOrdersContract,\n    getTokenTransferProxy,\n  };\n};\n","import type { ApproveToken } from '../../helpers/approve';\nimport type { ExtractAbiMethodNames } from '../../helpers/misc';\nimport type {\n  Address,\n  ConstructProviderFetchInput,\n  TxSendOverrides,\n} from '../../types';\nimport { constructApproveToken } from '../swap/approve';\nimport { constructGetNFTOrdersContract } from './getOrdersContract';\n\ntype ApproveNFT<T> = (\n  tokenAddress: Address,\n  overrides?: TxSendOverrides\n) => Promise<T>;\n\nexport type ApproveTokenForNFTOrderFunctions<T> = {\n  /** @description approving AugustusSwapper as spender for takerAsset (ERC20) for Limit Orders that will be executed through it */\n  approveERC20ForNFTOrder: ApproveToken<T>;\n  /** @description approving AugustusRFQ as spender for makerAsset (NFT) */\n  approveNFTorNFTOrder: ApproveNFT<T>;\n};\n\nconst MinNFTAbi = [\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_operator',\n        type: 'address',\n      },\n      {\n        name: '_approved',\n        type: 'bool',\n      },\n    ],\n    name: 'setApprovalForAll',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype ApprovalMethods = ExtractAbiMethodNames<typeof MinNFTAbi>;\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructApproveTokenForNFTOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): ApproveTokenForNFTOrderFunctions<T> => {\n  // approving TokenTransaferProxy as for the swap\n  const { approveToken: approveERC20ForNFTOrder } =\n    constructApproveToken(options);\n\n  const { getNFTOrdersContract } = constructGetNFTOrdersContract(options);\n\n  // @TODO add approvetakerAssetForNFTOrder to use AugustusSwapper as spender if we ever have SELL NFT swaps\n  const AugustusRFQ = getNFTOrdersContract();\n\n  const approveNFTorNFTOrder: ApproveNFT<T> = async (\n    tokenAddress,\n    overrides = {}\n  ) => {\n    const res = await options.contractCaller.transactCall<ApprovalMethods>({\n      address: tokenAddress,\n      abi: MinNFTAbi,\n      contractMethod: 'setApprovalForAll',\n      args: [AugustusRFQ, true],\n      overrides,\n    });\n\n    return res;\n  };\n\n  return { approveERC20ForNFTOrder, approveNFTorNFTOrder };\n};\n","import type { Address, ConstructFetchInput, OptimalRate } from '../../types';\n\nimport { assert } from 'ts-essentials';\nimport {\n  API_URL,\n  SwapSide,\n  ContractMethod,\n  DEFAULT_VERSION,\n} from '../../constants';\nimport {\n  BuildNFTOrderTxInput,\n  BuildOptions,\n  BuildSwapAndNFTOrderTxInput,\n  TransactionParams,\n  constructBuildTx,\n} from '../swap/transaction';\nimport { constructGetRate, GetRateInput, RateOptions } from '../swap/rates';\nimport type { BigIntAsString, NFTOrderData } from './buildOrder';\nimport { isFilledArray } from '../../helpers/misc';\n\ntype MinBuildSwapAndNFTOrderTxInput = Omit<\n  // these are derived from `orders`\n  BuildSwapAndNFTOrderTxInput,\n  'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'\n>;\n\ntype BuildSwapAndNFTOrdersTx = (\n  params: MinBuildSwapAndNFTOrderTxInput,\n  options?: BuildOptions,\n  signal?: AbortSignal\n) => Promise<TransactionParams>;\n\ntype MinBuildNFTOrderTxInput = Omit<\n  BuildNFTOrderTxInput,\n  // these are derived from `orders`\n  'srcToken' | 'srcAmount' | 'destToken' | 'slippage'\n  // `slippage` doesn't participate as we derive `srcAmount` already\n>;\n\ntype BuildNFTOrdersTx = (\n  params: MinBuildNFTOrderTxInput,\n  options?: BuildOptions,\n  signal?: AbortSignal\n) => Promise<TransactionParams>;\n\nexport type BuildNFTOrdersTxFunctions = {\n  getNFTOrdersRate: GetNFTOrdersRate;\n  buildNFTOrderTx: BuildNFTOrdersTx;\n  buildSwapAndNFTOrderTx: BuildSwapAndNFTOrdersTx;\n};\n\ntype GetNFTOrdersRate = (\n  // `amount`, if given, must equal the total of the orders' `takerAmounts`\n  options: Omit<GetRateInput, 'amount' | 'side'> & { amount?: string },\n  orders: CheckableOrderData[],\n  signal?: AbortSignal\n) => Promise<OptimalRate>;\n\nexport const constructBuildNFTOrderTx = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): BuildNFTOrdersTxFunctions => {\n  const { buildTx: buildSwapTx } = constructBuildTx({\n    apiURL,\n    version,\n    chainId,\n    fetcher,\n  });\n\n  const { getRate: getSwapAndNFTOrderRate } = constructGetRate({\n    apiURL,\n    version,\n    chainId,\n    fetcher,\n  });\n\n  //  returns priceRoute that would allow from swap from srcToken to destToken(=order.takerAsset) followed by filling NFT orders\n  const getNFTOrdersRate: GetNFTOrdersRate = async (\n    { srcToken, destToken, amount, options: _options = {}, ...rest },\n    orders,\n    signal\n  ) => {\n    assert(orders.length > 0, 'must pass at least 1 order');\n\n    const { totalTakerAmount, takerAsset } = checkAndParseOrders(orders);\n\n    assert(\n      takerAsset.toLowerCase() === destToken.toLowerCase(),\n      'All orders must have the same takerAsset as destToken'\n    );\n\n    const takerAmountString = totalTakerAmount.toString(10);\n\n    if (amount) {\n      assert(\n        amount === takerAmountString,\n        \"`amount` must equal the total of the orders' `takerAmounts`\"\n      );\n    }\n\n    // The pricing must use includeContractMethods=simpleBuy and side=BUY\n    const options: RateOptions = {\n      ..._options,\n      includeContractMethods: [ContractMethod.simpleBuy],\n    };\n\n    const side = SwapSide.BUY;\n\n    const rateInput: GetRateInput = {\n      ...rest,\n      srcToken,\n      destToken,\n      amount: takerAmountString,\n      side,\n      options,\n    };\n\n    // priceRoute\n    const optimalRate = await getSwapAndNFTOrderRate(rateInput, signal);\n    return optimalRate;\n  };\n\n  // derive srcToken, destToken and srcAmount from orders[]\n  const buildNFTOrderTx: BuildNFTOrdersTx = (params, options, signal) => {\n    const { takerAsset, totalTakerAmount } = checkAndParseOrders(params.orders);\n\n    const fillParams: BuildNFTOrderTxInput = {\n      ...params,\n      // taker supplies takerAsset\n      srcToken: takerAsset,\n      srcAmount: totalTakerAmount.toString(10),\n      // taker gets makerAsset in the end\n      destToken: 'NFT', // support any NFT\n    };\n\n    return buildSwapTx(fillParams, options, signal);\n  };\n  const buildSwapAndNFTOrderTx: BuildSwapAndNFTOrdersTx = (\n    params,\n    options,\n    signal\n  ) => {\n    checkAndParseOrders(params.orders);\n\n    const fillParams: BuildSwapAndNFTOrderTxInput = {\n      ...params,\n      // taker supplies srcToken\n      srcToken: params.priceRoute.srcToken,\n      // one or the other\n      ...(params.slippage\n        ? { slippage: params.slippage }\n        : //                                        may sneak in as part of `params`\n          { srcAmount: params.priceRoute.srcAmount, slippage: undefined }),\n      destToken: 'NFT', // support any NFT,\n      destDecimals: params.priceRoute.destDecimals,\n    };\n    return buildSwapTx(fillParams, options, signal);\n  };\n\n  return {\n    getNFTOrdersRate,\n    buildNFTOrderTx,\n    buildSwapAndNFTOrderTx,\n  };\n};\n\ntype CheckAndParseOrdersResult = Omit<CheckableOrderData, 'takerAmount'> & {\n  totalTakerAmount: bigint;\n};\n\ntype CheckableOrderData = Pick<\n  NFTOrderData,\n  'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'\n> & { taker?: NFTOrderData['taker'] };\n\nfunction checkAndParseOrders(\n  orders: CheckableOrderData[]\n): CheckAndParseOrdersResult {\n  assert(isFilledArray(orders), 'must pass at least 1 order');\n\n  const { takerAssetsSet, makerAssetsSet, totalTakerAmount } = orders.reduce<\n    Record<'takerAssetsSet' | 'makerAssetsSet', Set<string>> & {\n      totalTakerAmount: bigint;\n    }\n  >(\n    (accum, order) => {\n      accum.takerAssetsSet.add(order.takerAsset.toLowerCase());\n      accum.makerAssetsSet.add(order.makerAsset.toLowerCase());\n\n      accum.totalTakerAmount =\n        accum.totalTakerAmount + BigInt(order.takerAmount);\n      return accum;\n    },\n    {\n      takerAssetsSet: new Set(),\n      makerAssetsSet: new Set(),\n      totalTakerAmount: BigInt(0),\n    }\n  );\n\n  assert(\n    takerAssetsSet.size === 1,\n    'All orders must have the same takerAsset as destToken'\n  );\n  assert(makerAssetsSet.size === 1, 'All orders must have the same makerAsset');\n\n  const [{ maker, taker, makerAsset, takerAsset }] = orders;\n\n  return {\n    totalTakerAmount,\n    maker,\n    taker,\n    makerAsset: makerAsset.startsWith('0x')\n      ? makerAsset\n      : uintToAssetAddress(makerAsset),\n    takerAsset: takerAsset.startsWith('0x')\n      ? takerAsset\n      : uintToAssetAddress(takerAsset),\n  };\n}\n\n// extract asset address from makerAsset or takerAsset packed number encoded to contain AssetType\nfunction uintToAssetAddress(assetUint: BigIntAsString): Address {\n  return (\n    '0x' +\n    (BigInt(assetUint) & ((BigInt(1) << BigInt(160)) - BigInt(1))).toString(16)\n  );\n}\n","import type { ExtraFetchParams, FetcherFunction } from '../../types';\nimport type { AxiosStatic } from 'axios';\nimport { FetcherError } from '../misc';\n\nexport type AxiosRequirement = Pick<AxiosStatic, 'request' | 'isAxiosError'>;\n\nexport const constructFetcher =\n  (axios: AxiosRequirement, extra?: ExtraFetchParams): FetcherFunction =>\n  async (params) => {\n    try {\n      // adding apiKey to headers if it's provided\n      const headers = extra?.apiKey\n        ? { 'X-API-KEY': extra.apiKey, ...params.headers }\n        : params.headers;\n      const { data } = await axios.request({ ...params, headers });\n\n      return data;\n    } catch (error: any) {\n      if (axios.isAxiosError(error)) {\n        // attach a more meaningful message and other props\n        throw new FetcherError(error);\n      }\n\n      throw error;\n    }\n  };\n","import type { ExtraFetchParams, FetcherFunction } from '../../types';\nimport { FetcherError } from '../misc';\n\n// @TODO may not work with node-fetch\ntype Fetch = typeof fetch;\n\nexport const constructFetcher =\n  (fetch: Fetch, extra?: ExtraFetchParams): FetcherFunction =>\n  async (params) => {\n    try {\n      const { url, method, signal } = params;\n      const body = method === 'POST' ? JSON.stringify(params.data) : null;\n      // Only JSON response for POST requests\n      const POSTheaders =\n        method === 'POST' && body\n          ? {\n              'Content-Type': 'application/json',\n            }\n          : undefined;\n\n      // adding apiKey to headers if it's provided\n      const apiHeaders = extra?.apiKey\n        ? { 'X-API-KEY': extra.apiKey, ...params.headers }\n        : undefined;\n\n      // all headers combined\n      const headers =\n        POSTheaders || apiHeaders || params.headers\n          ? { ...apiHeaders, ...POSTheaders, ...params.headers }\n          : undefined;\n\n      const response = await fetch(url, { method, body, signal, headers });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        // @TODO figure out if this works analogous to AxiosError, especially code ==? status\n        throw new FetcherError({\n          code: String(response.status),\n          response: {\n            data,\n            status: response.status,\n            statusText: response.statusText,\n            headers: Object.fromEntries(response.headers.entries()),\n            config: { url, method },\n          },\n          message: response.statusText,\n          isAxiosError: false,\n        });\n      }\n\n      return data;\n    } catch (error: any) {\n      if (error instanceof FetcherError) throw error;\n      throw new FetcherError(error);\n    }\n  };\n","import type {\n  Address,\n  ContractCallerFunctions,\n  NoExtraKeysCheck,\n  SignTypedDataContractCallerFn,\n  StaticContractCallerFn,\n  TransactionContractCallerFn,\n} from '../../types';\nimport type {\n  JsonRpcProvider,\n  BaseProvider,\n  JsonRpcSigner,\n} from '@ethersproject/providers';\nimport type { Signer } from '@ethersproject/abstract-signer';\nimport type {\n  Contract as EthersContract,\n  PayableOverrides,\n  CallOverrides,\n  ContractTransaction,\n} from '@ethersproject/contracts';\nimport { assertEthersContractHasMethods } from '../misc';\nimport { assert } from 'ts-essentials';\n\nexport interface EthersProviderDeps {\n  ethersProviderOrSigner: BaseProvider | Signer;\n  EthersContract: typeof EthersContract; // passing Contract in allows not to include ethers as dependency even when using legacy ParaSwap class\n}\n\nexport const constructContractCaller = (\n  {\n    ethersProviderOrSigner: providerOrSigner,\n    EthersContract: Contract,\n  }: EthersProviderDeps,\n  account?: Address\n): ContractCallerFunctions<ContractTransaction> => {\n  const staticCall: StaticContractCallerFn = async (params) => {\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const contract = new Contract(address, abi, providerOrSigner);\n\n    assertEthersContractHasMethods(contract, contractMethod);\n    // drop keys not in CallOverrides\n    const { block, gas, ...restOverrides } = overrides;\n    // reassign values to keys in CallOverrides\n    const normalizedOverrides = {\n      ...restOverrides,\n      blockTag: block,\n      gasLimit: gas,\n    };\n\n    // type FinalCallOverrides = normalizedOverrides has extra props ? never : normalizedOverrides\n    type FinalCallOverrides = NoExtraKeysCheck<\n      typeof normalizedOverrides,\n      CallOverrides\n    >;\n\n    // enforce overrides shape ethers accepts\n    // TS will break if normalizedOverrides type has any keys not also present in CallOverrides\n    const callOverrides: FinalCallOverrides = normalizedOverrides;\n    // returns whatever the Contract.method returns: BigNumber, string, boolean\n    return contract.callStatic[contractMethod](...args, callOverrides);\n  };\n\n  const transactCall: TransactionContractCallerFn<ContractTransaction> = async (\n    params\n  ) => {\n    assert(account, 'account must be specified to create a signer');\n    assert(\n      isEthersProviderWithSigner(providerOrSigner) ||\n        isEthersSigner(providerOrSigner),\n      'ethers must be an instance of Signer or JsonRpcProvider to create a signer'\n    );\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const signer =\n      'getSigner' in providerOrSigner\n        ? providerOrSigner.getSigner(account)\n        : providerOrSigner;\n\n    const contract = new Contract(address, abi, signer);\n\n    assertEthersContractHasMethods(contract, contractMethod);\n    // drop keys not in PayableOverrides\n    const { gas, from, ...restOverrides } = overrides;\n    // reassign values to keys in PayableOverrides\n    const normalizedOverrides = {\n      ...restOverrides,\n      gasLimit: gas,\n    };\n\n    // type FinalPayableOverrides = normalizedOverrides has extra props ? never : normalizedOverrides\n    type FinalPayableOverrides = NoExtraKeysCheck<\n      typeof normalizedOverrides,\n      PayableOverrides\n    >;\n\n    // enforce overrides shape ethers accepts\n    // TS will break if normalizedOverrides type has any keys not also present in PayableOverrides\n    const txOverrides: FinalPayableOverrides = normalizedOverrides;\n    const txResponse: ContractTransaction = await contract[contractMethod](\n      ...args,\n      txOverrides\n    );\n\n    return txResponse;\n  };\n\n  const signTypedDataCall: SignTypedDataContractCallerFn = async (\n    typedData\n  ) => {\n    assert(account, 'account must be specified to create a signer');\n    assert(\n      isEthersProviderWithSigner(providerOrSigner) ||\n        isEthersSigner(providerOrSigner),\n      'ethers must be an instance of Signer or JsonRpcProvider to create a signer'\n    );\n\n    const signer =\n      'getSigner' in providerOrSigner\n        ? providerOrSigner.getSigner(account)\n        : providerOrSigner;\n\n    assert(isTypedDataCapableSigner(signer), 'Signer can sign typed data');\n\n    const { data, domain, types } = typedData;\n\n    return signer._signTypedData(domain, types, data);\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n};\n\nfunction isEthersProvider(\n  providerOrSigner: BaseProvider | Signer\n): providerOrSigner is BaseProvider {\n  return '_isProvider' in providerOrSigner && providerOrSigner._isProvider;\n}\n\nfunction isEthersProviderWithSigner(\n  providerOrSigner: JsonRpcProvider | BaseProvider | Signer\n): providerOrSigner is JsonRpcProvider {\n  return isEthersProvider(providerOrSigner) && 'getSigner' in providerOrSigner;\n}\n\nfunction isEthersSigner(\n  providerOrSigner: BaseProvider | Signer\n): providerOrSigner is Signer {\n  return '_isSigner' in providerOrSigner && providerOrSigner._isSigner;\n}\n\nfunction isTypedDataCapableSigner(\n  signer: Signer\n): signer is Signer & Pick<JsonRpcSigner, '_signTypedData'> {\n  return '_signTypedData' in signer;\n}\n","import type {\n  Address,\n  ContractCallerFunctions,\n  SignTypedDataContractCallerFn,\n  StaticContractCallerFn,\n  TransactionContractCallerFn,\n} from '../../types';\nimport type Web3 from 'web3';\nimport type { AbiItem } from 'web3-utils';\nimport type {\n  ContractSendMethod,\n  SendOptions,\n  CallOptions,\n  Contract,\n} from 'web3-eth-contract';\nimport type { PromiEvent, provider, AbstractProvider } from 'web3-core';\nimport type { JsonRpcResponse } from 'web3-core-helpers';\nimport { assert } from 'ts-essentials';\nimport { assertWeb3ContractHasMethods } from '../misc';\nimport type { TypedDataField } from '@ethersproject/abstract-signer';\n\nexport type Web3UnpromiEvent = Pick<PromiEvent<Contract>, 'on' | 'once'>;\n\nexport const constructContractCaller = (\n  web3: Web3,\n  account?: Address\n): ContractCallerFunctions<Web3UnpromiEvent> => {\n  const staticCall: StaticContractCallerFn = async (params) => {\n    assert(web3.currentProvider, 'web3.currentProvider is not set');\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const contract = new web3.eth.Contract(\n      abi as AbiItem[], // FIXME abi types ethers dependant\n      address\n    );\n\n    assertWeb3ContractHasMethods(contract, contractMethod);\n\n    const { block, gas, ...restOverrides } = overrides;\n\n    const normalizedOverrides: CallOptions = {\n      ...restOverrides,\n      gas,\n    };\n\n    return contract.methods[contractMethod](...args).call(normalizedOverrides);\n  };\n\n  const transactCall: TransactionContractCallerFn<Web3UnpromiEvent> = async (\n    params\n  ) => {\n    assert(web3.currentProvider, 'web3.currentProvider is not set');\n\n    assert(account, 'account must be specified to send transactions');\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const contract = new web3.eth.Contract(\n      abi as unknown as AbiItem[], // FIXME\n      address\n    );\n\n    assertWeb3ContractHasMethods(contract, contractMethod);\n\n    const { gas, from, ...restOverrides } = overrides;\n\n    const _from = from || account;\n\n    assert(_from, 'from is required');\n\n    const normalizedOverrides: SendOptions = {\n      ...restOverrides,\n      from: _from,\n      gas: gas,\n    };\n\n    const preparedCall = contract.methods[contractMethod](\n      ...args\n    ) as ContractSendMethod;\n\n    const promiEvent = preparedCall.send(normalizedOverrides);\n\n    // can't just return promiEvent, because async function returns a Promise<PromiEvent>\n    // and await Promise<PromiEvent> automatically awaits the value of PromiEvent,\n    // that is await Promise<PromiEvent> = Awaited<PromiEvent> that doesn't have .on|once\n    // so that functionality becomes lost\n    // transactCall can be made sync, but approve has to be async to await getSpender()\n    const unpromiEvent: Web3UnpromiEvent = {\n      on: promiEvent.on.bind(promiEvent),\n      once: promiEvent.once.bind(promiEvent),\n    };\n\n    return unpromiEvent;\n  };\n\n  const signTypedDataCall: SignTypedDataContractCallerFn = async (\n    typedData\n  ) => {\n    assert(web3.currentProvider, 'web3.currentProvider is not set');\n\n    assert(account, 'account must be specified to sign data');\n\n    const provider = web3.currentProvider;\n    assert(\n      isProviderWithSendMethod(provider),\n      'web3.currentProvider needs to be capable of sending arbitrary rpc calls'\n    );\n\n    const { data, domain, types } = typedData;\n\n    const _typedData = {\n      types: {\n        EIP712Domain: [\n          { name: 'name', type: 'string' },\n          { name: 'version', type: 'string' },\n          { name: 'chainId', type: 'uint256' },\n          { name: 'verifyingContract', type: 'address' },\n        ],\n        ...types,\n      },\n      primaryType: findPrimaryType(types),\n      domain,\n      message: data,\n    };\n\n    const response = await new Promise<JsonRpcResponse>((resolve, reject) => {\n      provider.send(\n        {\n          jsonrpc: '2.0',\n          // method: 'eth_signTypedData_v4',\n          method: 'eth_signTypedData',\n          params: [account, _typedData],\n        },\n        (error, result) => {\n          if (error) return reject(error);\n          if (!result) {\n            throw new Error('No result in response to eth_signTypedData');\n          }\n          resolve(result);\n        }\n      );\n    });\n\n    return response.result;\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n};\n\nfunction isProviderWithSendMethod<T extends provider>(\n  provider: T\n): provider is T & Required<Pick<AbstractProvider, 'send'>> {\n  return !!provider && typeof provider === 'object' && 'send' in provider;\n}\n\n// regex from @ethersproject/hash TypedDataEncoder.constructor\n// may be overly strict, but reliable\nconst baseTypeRegex = /^([^\\x5b]*)(\\x5b|$)/;\n\nfunction findPrimaryType(types: Record<string, TypedDataField[]>): string {\n  const candidates = Object.keys(types);\n  const candidatesSet = new Set(candidates);\n\n  candidates.forEach((candidate) => {\n    const typedDataFields = types[candidate];\n    if (!typedDataFields) return;\n\n    typedDataFields.forEach(({ type }) => {\n      // Get the base type (drop any array specifiers)\n      const baseType = type.match(baseTypeRegex)?.[1];\n      if (!baseType) return;\n\n      // if type was referred to as a child of another type, it can't be the primaryType\n      candidatesSet.delete(baseType);\n    });\n  });\n\n  const [primaryType] = Array.from(candidatesSet);\n\n  assert(\n    primaryType,\n    `No primary type found in SignableTypedData types, ${JSON.stringify(types)}`\n  );\n\n  return primaryType;\n}\n","import type {\n  AnyFunction,\n  ConstructBaseInput,\n  ConstructFetchInput,\n  ConstructProviderFetchInput,\n} from '../types';\nimport type { Merge, UnionToIntersection } from 'ts-essentials';\nimport type { ApproveTokenFunctions } from '../methods/swap/approve';\nimport type { CancelLimitOrderFunctions } from '../methods/limitOrders/cancelOrder';\nimport type { ApproveTokenForLimitOrderFunctions } from '../methods/limitOrders/approveForOrder';\nimport type { CancelNFTOrderFunctions } from '../methods/nftOrders/cancelOrder';\nimport type { ApproveTokenForNFTOrderFunctions } from '../methods/nftOrders/approveForOrder';\nimport { API_URL, DEFAULT_VERSION } from '../constants';\nimport { FillOrderDirectlyFunctions } from '../methods/limitOrders/fillOrderDirectly';\n\nexport type SDKConfig<TxResponse = any> = ConstructProviderFetchInput<\n  TxResponse,\n  'staticCall' | 'transactCall' | 'signTypedDataCall'\n> &\n  ConstructFetchInput;\n\ntype SDKFunction<T extends ConstructBaseInput> = (\n  config: T\n) => Record<string, AnyFunction | Record<string, AnyFunction>>;\n\ntype IntersectionOfReturns<Funcs extends AnyFunction[]> = UnionToIntersection<\n  ReturnType<Funcs[number]>\n>;\n\ntype PartialSDKResult<\n  Config extends ConstructBaseInput,\n  Funcs extends [SDKFunction<Config>, ...SDKFunction<Config>[]]\n> = InferWithTxResponse<Config, Funcs>;\n\ntype InferWithTxResponse<\n  Config extends ConstructBaseInput,\n  Funcs extends [SDKFunction<Config>, ...SDKFunction<Config>[]]\n> = Config extends SDKConfig<infer TxResponse> // if can infer TxResponse inside Config\n  ? // and if returns can be successfully intersected\n    IntersectionOfReturns<Funcs> extends Record<string, any>\n    ? MergeExtendableRecursively<\n        IntersectionOfReturns<Funcs>,\n        [\n          // if there are ApproveTokenFunctions or CancelLimitOrderFunctions in the intersection\n          // which means constructApproveToken or constructCancelLimitOrder was passed in Funcs\n          ApproveTokenFunctions<TxResponse>,\n          CancelLimitOrderFunctions<TxResponse>,\n          FillOrderDirectlyFunctions<TxResponse>,\n          ApproveTokenForLimitOrderFunctions<TxResponse>,\n          CancelNFTOrderFunctions<TxResponse>,\n          ApproveTokenForNFTOrderFunctions<TxResponse>\n        ]\n        // then merge IntersectionOfReturns<Funcs> with them recursively\n      >\n    : IntersectionOfReturns<Funcs>\n  : IntersectionOfReturns<Funcs>;\n\n// merges Accum with Replacement\n// if Accum has keys of Replacement\ntype MergeExtendableOnce<\n  Accum extends Record<string, any>,\n  Replacement extends Record<string, any>\n> = Accum extends Record<keyof Replacement, any>\n  ? Merge<Accum, Replacement>\n  : Accum;\n\n// recursively merges Accum with each Replacement\n// if Accum has keys of Replacement\ntype MergeExtendableRecursively<\n  Accum extends Record<string, any>,\n  Replacements extends Record<string, any>[]\n> = Replacements extends [head: infer Head, ...tail: infer Tail] // use [head: infer Head extends Record<string, any>, ...tail: infer Tail] after Ts update\n  ? Tail extends Record<string, any>[]\n    ? Head extends Record<string, any>\n      ? MergeExtendableRecursively<MergeExtendableOnce<Accum, Head>, Tail>\n      : Accum\n    : Head extends Record<string, any>\n    ? MergeExtendableOnce<Accum, Head>\n    : Accum\n  : Accum;\n\n/** @description construct composable SDK with methods you choose yourself */\nexport const constructPartialSDK = <\n  Config extends ConstructBaseInput,\n  Funcs extends [SDKFunction<Config>, ...SDKFunction<Config>[]]\n>(\n  config: Config, // config is auto-inferred to cover the used functions\n  ...funcs: Funcs\n): PartialSDKResult<Config, Funcs> & Required<ConstructBaseInput> => {\n  const sdkFuncs = funcs.reduce<Partial<IntersectionOfReturns<Funcs>>>(\n    (accum, func) => {\n      const sdkSlice = func(config);\n      return Object.assign(accum, sdkSlice);\n    },\n    {}\n  );\n\n  const sdk = {\n    ...sdkFuncs,\n    apiURL: config.apiURL ?? API_URL,\n    version: config.version ?? DEFAULT_VERSION,\n    chainId: config.chainId,\n  } as PartialSDKResult<Config, Funcs> & Required<ConstructBaseInput>;\n\n  return sdk;\n};\n","import { constructPartialSDK, SDKConfig } from '../../sdk/partial';\nimport { ConstructProviderFetchInput } from '../../types';\nimport { constructGetAdapters, GetAdaptersFunctions } from './adapters';\nimport { ApproveTokenFunctions, constructApproveToken } from './approve';\nimport { constructGetBalances, GetBalancesFunctions } from './balance';\nimport { constructGetRate, GetRateFunctions } from './rates';\nimport { constructGetSpender, GetSpenderFunctions } from './spender';\nimport { constructSwapTx, GetSwapTxFunctions } from './swapTx';\nimport { constructGetTokens, GetTokensFunctions } from './token';\nimport { BuildTxFunctions, constructBuildTx } from './transaction';\n\nexport type SwapSDKMethods<TxResponse> = GetBalancesFunctions &\n  GetTokensFunctions &\n  GetSpenderFunctions &\n  ApproveTokenFunctions<TxResponse> &\n  BuildTxFunctions &\n  GetAdaptersFunctions &\n  GetRateFunctions &\n  GetSwapTxFunctions;\n\n/** @description construct SDK with every Swap-related method, fetching from API and token approval */\nexport const constructSwapSDK = <TxResponse>(\n  config: SDKConfig<TxResponse>\n): SwapSDKMethods<TxResponse> =>\n  // include all available Swap methods\n  constructPartialSDK(\n    config,\n    constructGetBalances,\n    constructGetTokens,\n    constructGetSpender,\n    constructApproveToken as (\n      options: ConstructProviderFetchInput<TxResponse, 'transactCall'>\n    ) => ApproveTokenFunctions<TxResponse>, // @TODO try Instantiation Expression when TS 4.7 `as constructApproveToken<TxResponse>`\n    constructBuildTx,\n    constructGetAdapters,\n    constructGetRate,\n    constructSwapTx\n  );\n","import type { ConstructProviderFetchInput } from '../../types';\nimport type { LimitOrderToSend, LimitOrderFromApi } from './helpers/types';\nimport {\n  BuildLimitOrderFunctions,\n  BuildLimitOrderInput,\n  constructBuildLimitOrder,\n} from './buildOrder';\nimport {\n  CancelLimitOrderFunctions,\n  constructCancelLimitOrder,\n} from './cancelOrder';\nimport { constructGetLimitOrders, GetLimitOrdersFunctions } from './getOrders';\nimport { constructPostLimitOrder, PostLimitOrderFunctions } from './postOrder';\nimport { constructSignLimitOrder, SignLimitOrderFunctions } from './signOrder';\nimport {\n  constructApproveTokenForLimitOrder,\n  ApproveTokenForLimitOrderFunctions,\n} from './approveForOrder';\nimport {\n  GetLimitOrdersContractFunctions,\n  constructGetLimitOrdersContract,\n} from './getOrdersContract';\nimport {\n  BuildLimitOrdersTxFunctions,\n  constructBuildLimitOrderTx,\n} from './transaction';\nimport type { Address } from '@paraswap/core';\nimport {\n  FillOrderDirectlyFunctions,\n  constructFillOrderDirectly,\n} from './fillOrderDirectly';\n\ntype SubmitLimitOrder = (\n  buildLimitOrderParams: BuildLimitOrderInput,\n  extra?: { permitMakerAsset?: string },\n  signal?: AbortSignal\n) => Promise<LimitOrderFromApi>;\n\ntype SubmitP2POrder = (\n  buildLimitOrderParams: BuildLimitOrderInput & { taker: Address },\n  extra?: { permitMakerAsset?: string },\n  signal?: AbortSignal\n) => Promise<LimitOrderFromApi>;\n\nexport type SubmitLimitOrderFuncs = {\n  submitLimitOrder: SubmitLimitOrder;\n  submitP2POrder: SubmitP2POrder;\n};\n\nexport const constructSubmitLimitOrder = (\n  options: ConstructProviderFetchInput<any, 'signTypedDataCall'>\n): SubmitLimitOrderFuncs => {\n  const { buildLimitOrder } = constructBuildLimitOrder(options);\n  const { signLimitOrder } = constructSignLimitOrder(options);\n  const { postLimitOrder, postP2POrder } = constructPostLimitOrder(options);\n\n  const prepareLimitOrder = async (\n    buildLimitOrderParams: BuildLimitOrderInput,\n    extra?: { permitMakerAsset?: string }\n  ): Promise<LimitOrderToSend> => {\n    const orderData = await buildLimitOrder(buildLimitOrderParams);\n    const signature = await signLimitOrder(orderData);\n\n    const orderWithSignature: LimitOrderToSend = {\n      ...orderData.data,\n      ...extra,\n      signature,\n    };\n\n    return orderWithSignature;\n  };\n\n  const submitLimitOrder: SubmitLimitOrder = async (\n    buildLimitOrderParams,\n    extra = {},\n    signal\n  ) => {\n    const orderWithSignature: LimitOrderToSend = await prepareLimitOrder(\n      buildLimitOrderParams,\n      extra\n    );\n\n    const newOrder = await postLimitOrder(orderWithSignature, signal);\n\n    return newOrder;\n  };\n\n  const submitP2POrder: SubmitP2POrder = async (\n    buildLimitOrderParams,\n    extra = {},\n    signal\n  ) => {\n    const orderWithSignature: LimitOrderToSend = await prepareLimitOrder(\n      buildLimitOrderParams,\n      extra\n    );\n\n    const newOrder = await postP2POrder(orderWithSignature, signal);\n\n    return newOrder;\n  };\n\n  return { submitLimitOrder, submitP2POrder };\n};\n\nexport type LimitOrderHandlers<T> = SubmitLimitOrderFuncs &\n  BuildLimitOrderFunctions &\n  SignLimitOrderFunctions &\n  PostLimitOrderFunctions &\n  GetLimitOrdersFunctions &\n  GetLimitOrdersContractFunctions &\n  BuildLimitOrdersTxFunctions &\n  CancelLimitOrderFunctions<T> &\n  ApproveTokenForLimitOrderFunctions<T> &\n  FillOrderDirectlyFunctions<T>;\n\n/** @description construct SDK with every LimitOrders-related method, fetching from API and contract calls */\nexport const constructAllLimitOrdersHandlers = <TxResponse>(\n  options: ConstructProviderFetchInput<\n    TxResponse,\n    'signTypedDataCall' | 'transactCall' | 'staticCall'\n  >\n): LimitOrderHandlers<TxResponse> => {\n  const limitOrdersGetters = constructGetLimitOrders(options);\n  const limitOrdersContractGetter = constructGetLimitOrdersContract(options);\n\n  const limitOrdersSubmit = constructSubmitLimitOrder(options);\n  const limitOrdersBuild = constructBuildLimitOrder(options);\n  const limitOrdersSign = constructSignLimitOrder(options);\n  const limitOrdersPost = constructPostLimitOrder(options);\n\n  const limitOrdersCancel = constructCancelLimitOrder(options);\n  const limitOrdersApproveToken = constructApproveTokenForLimitOrder(options);\n\n  const limitOrdersFillOrderDirectly = constructFillOrderDirectly(options);\n\n  const limitOrdersBuildTx = constructBuildLimitOrderTx(options);\n\n  return {\n    ...limitOrdersGetters,\n    ...limitOrdersContractGetter,\n    ...limitOrdersSubmit,\n    ...limitOrdersBuild,\n    ...limitOrdersSign,\n    ...limitOrdersPost,\n    ...limitOrdersCancel,\n    ...limitOrdersApproveToken,\n    ...limitOrdersFillOrderDirectly,\n    ...limitOrdersBuildTx,\n  };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport type { NFTOrderToSend, NFTOrderFromAPI } from './helpers/types';\nimport {\n  BuildNFTOrderFunctions,\n  BuildNFTOrderInput,\n  constructBuildNFTOrder,\n} from './buildOrder';\nimport {\n  CancelNFTOrderFunctions,\n  constructCancelNFTOrder,\n} from './cancelOrder';\nimport { constructGetNFTOrders, GetNFTOrdersFunctions } from './getOrders';\nimport { constructPostNFTOrder, PostNFTOrderFunctions } from './postOrder';\nimport { constructSignNFTOrder, SignNFTOrderFunctions } from './signOrder';\nimport {\n  constructApproveTokenForNFTOrder,\n  ApproveTokenForNFTOrderFunctions,\n} from './approveForOrder';\nimport {\n  GetNFTOrdersContractFunctions,\n  constructGetNFTOrdersContract,\n} from './getOrdersContract';\nimport {\n  BuildNFTOrdersTxFunctions,\n  constructBuildNFTOrderTx,\n} from './transaction';\n\ntype SubmitNFTOrder = (\n  buildNFTOrderParams: BuildNFTOrderInput,\n  extra?: { permitMakerAsset?: string },\n  signal?: AbortSignal\n) => Promise<NFTOrderFromAPI>;\n\nexport type SubmitNFTOrderFuncs = {\n  submitNFTOrder: SubmitNFTOrder;\n  submitP2POrder: SubmitNFTOrder;\n};\n\nexport const constructSubmitNFTOrder = (\n  options: ConstructProviderFetchInput<any, 'signTypedDataCall'>\n): SubmitNFTOrderFuncs => {\n  const { buildNFTOrder } = constructBuildNFTOrder(options);\n  const { signNFTOrder } = constructSignNFTOrder(options);\n  const { postNFTLimitOrder, postNFTP2POrder } = constructPostNFTOrder(options);\n\n  const prepareNFTOrder = async (\n    buildNFTOrderParams: BuildNFTOrderInput,\n    extra?: { permitMakerAsset?: string }\n  ): Promise<NFTOrderToSend> => {\n    const orderData = await buildNFTOrder(buildNFTOrderParams);\n    const signature = await signNFTOrder(orderData);\n\n    const orderWithSignature: NFTOrderToSend = {\n      ...orderData.data,\n      ...extra,\n      signature,\n    };\n\n    return orderWithSignature;\n  };\n\n  const submitNFTOrder: SubmitNFTOrder = async (\n    buildNFTOrderParams,\n    extra = {},\n    signal\n  ) => {\n    const orderWithSignature: NFTOrderToSend = await prepareNFTOrder(\n      buildNFTOrderParams,\n      extra\n    );\n\n    const newOrder = await postNFTLimitOrder(orderWithSignature, signal);\n\n    return newOrder;\n  };\n\n  const submitP2POrder: SubmitNFTOrder = async (\n    buildNFTOrderParams,\n    extra = {},\n    signal\n  ) => {\n    const orderWithSignature: NFTOrderToSend = await prepareNFTOrder(\n      buildNFTOrderParams,\n      extra\n    );\n\n    const newOrder = await postNFTP2POrder(orderWithSignature, signal);\n\n    return newOrder;\n  };\n\n  return { submitNFTOrder, submitP2POrder };\n};\n\nexport type NFTOrderHandlers<T> = SubmitNFTOrderFuncs &\n  BuildNFTOrderFunctions &\n  SignNFTOrderFunctions &\n  PostNFTOrderFunctions &\n  GetNFTOrdersFunctions &\n  GetNFTOrdersContractFunctions &\n  BuildNFTOrdersTxFunctions &\n  CancelNFTOrderFunctions<T> &\n  ApproveTokenForNFTOrderFunctions<T>;\n\n/** @description construct SDK with every NFTOrders-related method, fetching from API and contract calls */\nexport const constructAllNFTOrdersHandlers = <TxResponse>(\n  options: ConstructProviderFetchInput<\n    TxResponse,\n    'signTypedDataCall' | 'transactCall' | 'staticCall'\n  >\n): NFTOrderHandlers<TxResponse> => {\n  const NFTOrdersGetters = constructGetNFTOrders(options);\n  const NFTOrdersContractGetter = constructGetNFTOrdersContract(options);\n\n  const NFTOrdersSubmit = constructSubmitNFTOrder(options);\n  const NFTOrdersBuild = constructBuildNFTOrder(options);\n  const NFTOrdersSign = constructSignNFTOrder(options);\n  const NFTOrdersPost = constructPostNFTOrder(options);\n\n  const NFTOrdersCancel = constructCancelNFTOrder(options);\n  const NFTOrdersApproveToken = constructApproveTokenForNFTOrder(options);\n\n  const NFTOrdersBuildTx = constructBuildNFTOrderTx(options);\n\n  return {\n    ...NFTOrdersGetters,\n    ...NFTOrdersContractGetter,\n    ...NFTOrdersSubmit,\n    ...NFTOrdersBuild,\n    ...NFTOrdersSign,\n    ...NFTOrdersPost,\n    ...NFTOrdersCancel,\n    ...NFTOrdersApproveToken,\n    ...NFTOrdersBuildTx,\n  };\n};\n","import type Web3 from 'web3';\nimport type { SendOptions } from 'web3-eth-contract';\nimport type { ContractTransaction } from '@ethersproject/contracts';\n\nimport { API_URL, DEFAULT_VERSION, SwapSide } from '../constants';\nimport {\n  SwapSDKMethods,\n  constructBuildTx,\n  constructGetAdapters,\n  constructGetBalances,\n  constructGetSpender,\n  constructGetTokens,\n  constructPartialSDK,\n  constructGetRate,\n  constructSwapSDK,\n  PriceString,\n  Address,\n  OptimalRate,\n} from '..';\nimport { assert } from 'ts-essentials';\nimport {\n  constructAxiosFetcher,\n  constructFetchFetcher,\n  constructEthersContractCaller,\n  constructWeb3ContractCaller,\n  isFetcherError,\n  Web3UnpromiEvent,\n  EthersProviderDeps,\n} from '../helpers';\n\nimport type { RateOptions } from '../methods/swap/rates';\nimport type {\n  BuildOptions,\n  TransactionParams,\n} from '../methods/swap/transaction';\nimport type {\n  AddressOrSymbol,\n  Token,\n  FetcherFunction,\n  ParaSwapVersionUnion,\n} from '../types';\nimport type { Allowance } from '../methods/swap/balance';\nimport type { AxiosRequirement } from '../helpers/fetchers/axios';\nimport { isDataWithError } from '../helpers/misc';\n\nexport type APIError = {\n  message: string;\n  status?: number;\n  data?: any;\n};\ntype Fetch = typeof fetch;\n\ntype TxResponse = Web3UnpromiEvent | ContractTransaction;\n\ntype LegacyOptions = {\n  chainId?: number;\n  apiURL?: string;\n  version?: ParaSwapVersionUnion;\n  apiKey?: string;\n  web3Provider?: Web3;\n  ethersDeps?: EthersProviderDeps; // need to be a provider with signer for approve requests\n  account?: Address;\n  axios?: AxiosRequirement;\n  fetch?: Fetch;\n};\n\n/** @deprecated */\nexport class ParaSwap {\n  sdk: Partial<SwapSDKMethods<TxResponse>> = {};\n  fetcher: FetcherFunction;\n\n  chainId: number;\n  apiURL: string;\n  version: ParaSwapVersionUnion;\n  web3Provider?: Web3;\n  ethersDeps?: EthersProviderDeps; // need to be a provider with signer for approve requests\n  account?: Address;\n\n  constructor({\n    chainId = 1,\n    apiURL = API_URL,\n    version = DEFAULT_VERSION,\n    apiKey,\n    web3Provider,\n    ethersDeps,\n    account,\n    axios,\n    fetch,\n  }: LegacyOptions) {\n    this.chainId = chainId;\n    this.apiURL = apiURL;\n    this.version = version;\n    this.web3Provider = web3Provider;\n    this.ethersDeps = ethersDeps;\n    this.account = account;\n\n    const fetcher = axios\n      ? constructAxiosFetcher(axios, { apiKey })\n      : fetch\n      ? constructFetchFetcher(fetch, { apiKey })\n      : null;\n\n    assert(fetcher, 'at least one fetcher is needed');\n    this.fetcher = fetcher;\n\n    if (!web3Provider && !ethersDeps) {\n      this.sdk = constructPartialSDK(\n        { fetcher, apiURL, version, apiKey, chainId },\n        constructGetBalances,\n        constructGetTokens,\n        constructGetSpender,\n        constructBuildTx,\n        constructGetAdapters,\n        constructGetRate\n      );\n\n      return;\n    }\n\n    const contractCaller = ethersDeps\n      ? constructEthersContractCaller(ethersDeps, account)\n      : web3Provider\n      ? constructWeb3ContractCaller(web3Provider, account)\n      : null;\n\n    if (contractCaller) {\n      this.sdk = constructSwapSDK<TxResponse>({\n        fetcher,\n        contractCaller,\n        apiURL,\n        version,\n        chainId,\n      });\n    }\n  }\n\n  private static handleAPIError(e: unknown): APIError {\n    // @CONSIDER if some errors should not be replaced\n    if (!isFetcherError(e)) {\n      return { message: `Unknown error: ${e}` };\n    }\n\n    if (!e.response) {\n      return { message: e.message };\n    }\n\n    const { status, data } = e.response;\n\n    return {\n      status,\n      message: isDataWithError(data) ? data.error : e.message,\n      data,\n    };\n  }\n\n  private static async extractHashFromTxResponse(\n    txResponse: TxResponse\n  ): Promise<string> {\n    if ('once' in txResponse) {\n      return new Promise<string>((resolve, reject) => {\n        txResponse.once('transactionHash', resolve);\n        txResponse.once('error', reject);\n      });\n    }\n\n    const { hash } = await txResponse;\n    return hash;\n  }\n\n  setWeb3Provider(web3Provider: Web3, account?: string): this {\n    const contractCaller = constructWeb3ContractCaller(web3Provider, account);\n    const { apiURL, chainId, fetcher } = this;\n\n    this.sdk = constructSwapSDK({\n      fetcher,\n      contractCaller,\n      apiURL,\n      version: this.version,\n      chainId,\n    });\n\n    this.web3Provider = web3Provider;\n    this.ethersDeps = undefined;\n    this.account = account;\n\n    return this;\n  }\n\n  setEthersProvider(ethersDeps: EthersProviderDeps, account?: string): this {\n    const contractCaller = constructEthersContractCaller(ethersDeps, account);\n    const { apiURL, chainId, fetcher } = this;\n\n    this.sdk = constructSwapSDK({\n      fetcher,\n      contractCaller,\n      apiURL,\n      version: this.version,\n      chainId,\n    });\n\n    this.web3Provider = undefined;\n    this.ethersDeps = ethersDeps;\n    this.account = account;\n\n    return this;\n  }\n\n  // @CONSIDER I still think there's no need for a class Token\n  async getTokens(): Promise<Token[] | APIError> {\n    assert(this.sdk.getTokens, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getTokens();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getAdapters() {\n    assert(this.sdk.getAdapters, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAdapters();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getRateByRoute(\n    route: AddressOrSymbol[],\n    amount: PriceString,\n    userAddress?: Address,\n    side: SwapSide = SwapSide.SELL,\n    options?: RateOptions,\n    srcDecimals?: number,\n    destDecimals?: number\n  ): Promise<OptimalRate | APIError> {\n    assert(this.sdk.getRateByRoute, 'sdk must be initialized with a fetcher');\n    if (route.length < 2) {\n      return { message: 'Invalid Route' };\n    }\n\n    try {\n      return await this.sdk.getRateByRoute({\n        route,\n        amount,\n        userAddress,\n        side,\n        options,\n        srcDecimals,\n        destDecimals,\n      });\n    } catch (e) {\n      // @TODO this overrides any non FetchError,\n      // including Error('Invalid DEX list')\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getRate(\n    srcToken: AddressOrSymbol,\n    destToken: AddressOrSymbol,\n    amount: PriceString,\n    userAddress?: Address,\n    side: SwapSide = SwapSide.SELL,\n    options: RateOptions = {},\n    srcDecimals?: number,\n    destDecimals?: number\n  ): Promise<OptimalRate | APIError> {\n    assert(this.sdk.getRate, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getRate({\n        srcToken,\n        destToken,\n        amount,\n        userAddress,\n        side,\n        options,\n        srcDecimals,\n        destDecimals,\n      });\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async buildTx(\n    srcToken: Address,\n    destToken: Address,\n    srcAmount: PriceString,\n    destAmount: PriceString,\n    priceRoute: OptimalRate,\n    userAddress: Address,\n    partner?: string,\n    partnerAddress?: string,\n    partnerFeeBps?: number,\n    receiver?: Address,\n    options: BuildOptions = {},\n    srcDecimals?: number,\n    destDecimals?: number,\n    permit?: string,\n    deadline?: string\n  ): Promise<TransactionParams | APIError> {\n    assert(this.sdk.buildTx, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.buildTx(\n        {\n          srcToken,\n          destToken,\n          srcAmount,\n          destAmount,\n          priceRoute,\n          userAddress,\n          partner,\n          partnerAddress,\n          partnerFeeBps,\n          receiver,\n          srcDecimals,\n          destDecimals,\n          permit,\n          deadline,\n        },\n        options\n      );\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getTokenTransferProxy(_provider?: any): Promise<Address | APIError> {\n    assert(this.sdk.getSpender, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getSpender();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getAllowances(\n    userAddress: Address,\n    tokenAddresses: Address[]\n  ): Promise<Allowance[] | APIError> {\n    assert(this.sdk.getAllowances, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAllowances(userAddress, tokenAddresses);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getAllowance(\n    userAddress: Address,\n    tokenAddress: Address\n  ): Promise<Allowance | APIError> {\n    assert(this.sdk.getAllowance, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAllowance(userAddress, tokenAddress);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async approveTokenBulk(\n    amount: PriceString,\n    userAddress: Address,\n    tokenAddresses: Address[],\n    /** @deprecated */\n    _provider?: any // not used, can't detect if Ethers or Web3 provider without importing them\n  ): Promise<string[] | APIError> {\n    // @TODO expand sendOptions\n    assert(\n      this.sdk.approveTokenBulk,\n      'sdk must be initialized with a provider'\n    );\n    try {\n      // @TODO allow to pass Web3 specific sendOptions ({from: userAddress})\n      const txResponses = await this.sdk.approveTokenBulk(\n        amount,\n        tokenAddresses\n      );\n\n      return await Promise.all(\n        txResponses.map(ParaSwap.extractHashFromTxResponse)\n      );\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async approveToken(\n    amount: PriceString,\n    userAddress: Address,\n    tokenAddress: Address,\n    /** @deprecated */\n    _provider?: any, // not used, can't detect if Ethers or Web3 provider without importing them\n    sendOptions?: Omit<SendOptions, 'from'>\n  ): Promise<string | APIError> {\n    // @TODO expand sendOptions\n    assert(this.sdk.approveToken, 'sdk must be initialized with a provider');\n    try {\n      // @TODO allow to pass Web3 specific sendOptions ({from: userAddress})\n      const txResponse = await this.sdk.approveToken(amount, tokenAddress);\n\n      return await ParaSwap.extractHashFromTxResponse(txResponse);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getMarketNames(): Promise<string[] | APIError> {\n    assert(this.sdk.getAdapters, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAdapters();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getBalance(\n    userAddress: Address,\n    token: AddressOrSymbol\n  ): Promise<Token | APIError> {\n    assert(this.sdk.getBalance, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getBalance(userAddress, token);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getBalances(userAddress: Address): Promise<Token[] | APIError> {\n    assert(this.sdk.getBalances, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getBalances(userAddress);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n}\n","import type { SDKConfig } from './partial';\nimport { constructSwapSDK, SwapSDKMethods } from '../methods/swap';\nimport {\n  constructAllLimitOrdersHandlers,\n  LimitOrderHandlers,\n} from '../methods/limitOrders';\nimport {\n  constructAllNFTOrdersHandlers,\n  NFTOrderHandlers,\n} from '../methods/nftOrders';\n\nexport type AllSDKMethods<TxResponse> = {\n  swap: SwapSDKMethods<TxResponse>;\n  limitOrders: LimitOrderHandlers<TxResponse>;\n  nftOrders: NFTOrderHandlers<TxResponse>;\n};\n\n/** @description construct SDK with every method, for swap and limitOrders */\nexport const constructFullSDK = <TxResponse = any>(\n  config: SDKConfig<TxResponse>\n): AllSDKMethods<TxResponse> => {\n  // include all available functions\n  const swap: SwapSDKMethods<TxResponse> = constructSwapSDK(config);\n  const limitOrders: LimitOrderHandlers<TxResponse> =\n    constructAllLimitOrdersHandlers(config);\n  const nftOrders: NFTOrderHandlers<TxResponse> =\n    constructAllNFTOrdersHandlers(config);\n\n  return { swap, limitOrders, nftOrders };\n};\n","import { constructPartialSDK, SDKConfig } from './partial';\nimport {\n  GetAdaptersFunctions,\n  constructGetAdapters,\n} from '../methods/swap/adapters';\nimport {\n  GetBalancesFunctions,\n  constructGetBalances,\n} from '../methods/swap/balance';\nimport { GetRateFunctions, constructGetRate } from '../methods/swap/rates';\nimport {\n  GetSpenderFunctions,\n  constructGetSpender,\n} from '../methods/swap/spender';\nimport { GetTokensFunctions, constructGetTokens } from '../methods/swap/token';\nimport {\n  BuildTxFunctions,\n  constructBuildTx,\n} from '../methods/swap/transaction';\nimport { constructSwapTx, GetSwapTxFunctions } from '../methods/swap/swapTx';\n\nimport {\n  constructAxiosFetcher,\n  constructFetchFetcher,\n  constructEthersContractCaller,\n  constructWeb3ContractCaller,\n} from '../helpers';\n\nimport type {\n  ConstructBaseInput,\n  ConstructFetchInput,\n  ContractCallerFunctions,\n  TransactionContractCallerFn,\n  TxHash,\n  Address,\n  FetcherFunction,\n  ExtraFetchParams,\n} from '../types';\n\nimport type { EthersProviderDeps } from '../helpers';\nimport type Web3 from 'web3';\n\nimport type { SwapSDKMethods } from '../methods/swap';\nimport {\n  BuildLimitOrderFunctions,\n  constructBuildLimitOrder,\n} from '../methods/limitOrders/buildOrder';\nimport {\n  constructPostLimitOrder,\n  PostLimitOrderFunctions,\n} from '../methods/limitOrders/postOrder';\nimport {\n  constructGetLimitOrders,\n  GetLimitOrdersFunctions,\n} from '../methods/limitOrders/getOrders';\nimport {\n  constructGetLimitOrdersContract,\n  GetLimitOrdersContractFunctions,\n} from '../methods/limitOrders/getOrdersContract';\nimport {\n  constructBuildLimitOrderTx,\n  BuildLimitOrdersTxFunctions,\n} from '../methods/limitOrders/transaction';\nimport {\n  constructAllLimitOrdersHandlers,\n  LimitOrderHandlers,\n} from '../methods/limitOrders';\n\nimport {\n  constructGetNFTOrdersContract,\n  GetNFTOrdersContractFunctions,\n} from '../methods/nftOrders/getOrdersContract';\nimport {\n  constructGetNFTOrders,\n  GetNFTOrdersFunctions,\n} from '../methods/nftOrders/getOrders';\nimport {\n  BuildNFTOrderFunctions,\n  constructBuildNFTOrder,\n} from '../methods/nftOrders/buildOrder';\nimport {\n  constructPostNFTOrder,\n  PostNFTOrderFunctions,\n} from '../methods/nftOrders/postOrder';\nimport {\n  constructBuildNFTOrderTx,\n  BuildNFTOrdersTxFunctions,\n} from '../methods/nftOrders/transaction';\nimport {\n  constructAllNFTOrdersHandlers,\n  NFTOrderHandlers,\n} from '../methods/nftOrders';\n\nimport { constructSwapSDK } from '../methods/swap';\nimport type { AxiosRequirement } from '../helpers/fetchers/axios';\nimport { API_URL, DEFAULT_VERSION } from '../constants';\n\nexport type SwapFetchMethods = GetBalancesFunctions &\n  GetTokensFunctions &\n  GetSpenderFunctions &\n  BuildTxFunctions &\n  GetAdaptersFunctions &\n  GetRateFunctions &\n  GetSwapTxFunctions;\n\nexport type LimitOrdersFetchMethods = GetLimitOrdersContractFunctions &\n  GetLimitOrdersFunctions &\n  BuildLimitOrderFunctions &\n  PostLimitOrderFunctions &\n  BuildLimitOrdersTxFunctions;\n\nexport type NFTOrdersFetchMethods = GetNFTOrdersContractFunctions &\n  GetNFTOrdersFunctions &\n  BuildNFTOrderFunctions &\n  PostNFTOrderFunctions &\n  BuildNFTOrdersTxFunctions;\n\nexport type SimpleFetchSDK = {\n  swap: SwapFetchMethods;\n  limitOrders: LimitOrdersFetchMethods;\n  nftOrders: NFTOrdersFetchMethods;\n} & Required<ConstructBaseInput>;\n\nexport type SimpleSDK = {\n  swap: SwapSDKMethods<TxHash>;\n  limitOrders: LimitOrderHandlers<TxHash>;\n  nftOrders: NFTOrderHandlers<TxHash>;\n} & Required<ConstructBaseInput>;\n\nexport type FetcherOptions = (\n  | {\n      axios: AxiosRequirement;\n    }\n  | { fetch: typeof fetch }\n  | { fetcher: FetcherFunction }\n) &\n  ExtraFetchParams;\n\ntype SimpleOptions = ConstructBaseInput & FetcherOptions;\n\nexport type ProviderOptions = (EthersProviderDeps | { web3: Web3 }) & {\n  account: Address;\n};\n\nconst constructFetcher = (options: FetcherOptions): FetcherFunction => {\n  if ('axios' in options) {\n    return constructAxiosFetcher(options.axios, options);\n  }\n  if ('fetch' in options) {\n    return constructFetchFetcher(options.fetch, options);\n  }\n  return (params) => {\n    // adding apiKey to headers if it's provided\n    const headers = options?.apiKey\n      ? { 'X-API-KEY': options.apiKey, ...params.headers }\n      : params.headers;\n\n    return options.fetcher({ ...params, headers });\n  };\n};\n\n/** @description construct SDK with methods that fetch from API and optionally with blockchain provider calling methods */\nexport function constructSimpleSDK(options: SimpleOptions): SimpleFetchSDK;\n\nexport function constructSimpleSDK(\n  options: SimpleOptions,\n  providerOptions: ProviderOptions\n): SimpleSDK;\nexport function constructSimpleSDK(\n  options: SimpleOptions,\n  providerOptions?: ProviderOptions\n): SimpleFetchSDK | SimpleSDK {\n  const fetcher = constructFetcher(options);\n\n  if (!providerOptions) {\n    const config: ConstructFetchInput = {\n      apiURL: options.apiURL,\n      chainId: options.chainId,\n      version: options.version,\n      fetcher,\n    };\n\n    // include all available functions that don't need `contractCaller`\n    const swap: SwapFetchMethods = constructPartialSDK(\n      config,\n      constructGetBalances,\n      constructGetTokens,\n      constructGetSpender,\n      constructBuildTx,\n      constructGetAdapters,\n      constructGetRate,\n      constructSwapTx\n    );\n\n    const limitOrders = constructPartialSDK(\n      config,\n      constructBuildLimitOrder,\n      constructPostLimitOrder,\n      constructGetLimitOrders,\n      constructGetLimitOrdersContract,\n      constructBuildLimitOrderTx\n    );\n\n    const nftOrders = constructPartialSDK(\n      config,\n      constructBuildNFTOrder,\n      constructPostNFTOrder,\n      constructGetNFTOrders,\n      constructGetNFTOrdersContract,\n      constructBuildNFTOrderTx\n    );\n\n    return {\n      swap,\n      limitOrders,\n      nftOrders,\n      apiURL: options.apiURL ?? API_URL,\n      chainId: options.chainId,\n      version: options.version ?? DEFAULT_VERSION,\n    };\n  }\n\n  const contractCaller = constructSimpleContractCaller(providerOptions);\n\n  const config: SDKConfig<TxHash> = {\n    apiURL: options.apiURL,\n    version: options.version,\n    chainId: options.chainId,\n    fetcher,\n    contractCaller,\n  };\n\n  const swap: SwapSDKMethods<TxHash> = constructSwapSDK(config);\n\n  const limitOrders: LimitOrderHandlers<TxHash> =\n    constructAllLimitOrdersHandlers<TxHash>(config);\n\n  const nftOrders: NFTOrderHandlers<TxHash> =\n    constructAllNFTOrdersHandlers<TxHash>(config);\n\n  return {\n    swap,\n    limitOrders,\n    nftOrders,\n    apiURL: options.apiURL ?? API_URL,\n    chainId: options.chainId,\n    version: options.version ?? DEFAULT_VERSION,\n  };\n}\n\nfunction constructSimpleContractCaller(\n  providerOptions: ProviderOptions\n): ContractCallerFunctions<TxHash> {\n  if ('ethersProviderOrSigner' in providerOptions) {\n    const {\n      staticCall,\n      transactCall: _transactCall,\n      signTypedDataCall,\n    } = constructEthersContractCaller(providerOptions, providerOptions.account);\n\n    const transactCall: TransactionContractCallerFn<TxHash> = async (\n      params\n    ) => {\n      const contractTx = await _transactCall(params);\n\n      // as soon as tx is sent\n      // returning tx hash, it's up to the user to wait for tx\n      return contractTx.hash;\n    };\n\n    return { staticCall, transactCall, signTypedDataCall };\n  }\n\n  const {\n    staticCall,\n    transactCall: _transactCall,\n    signTypedDataCall,\n  } = constructWeb3ContractCaller(\n    providerOptions.web3,\n    providerOptions.account\n  );\n\n  const transactCall: TransactionContractCallerFn<TxHash> = async (params) => {\n    const unpromiEvent = await _transactCall(params);\n\n    // as soon as tx is sent\n    // returning tx hash, it's up to the user to wait for tx\n    return new Promise<TxHash>((resolve, reject) => {\n      unpromiEvent.once('transactionHash', resolve);\n      unpromiEvent.once('error', reject);\n    });\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n}\n"],"names":["runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","API_URL","ethersContractHasMethods","contract","_len","arguments","methods","Array","_key","every","assertEthersContractHasMethods","_len2","_key2","assert","apply","join","web3ContractHasMethods","_len3","_key3","assertWeb3ContractHasMethods","_len4","_key4","constructSearchString","queryOptions","queryEntries","entries","filter","_ref","map","_ref2","String","queryString","URLSearchParams","toString","isFetcherError","FetcherError","_Error","_ref3","_this","code","request","response","isAxiosError","message","status","captureStackTrace","_assertThisInitialized","data","isDataWithError","isFilledArray","array","getRandomInt","Math","floor","random","Number","MAX_SAFE_INTEGER","constructGetSpender","func","_ref$apiURL","apiURL","_ref$version","version","fetcher","fetchURL","network","chainId","_getContracts","_asyncToGenerator","_regeneratorRuntime","signal","_context","url","_callee","_x","getContracts","_result","getSpender","_context2","TokenTransferProxy","_callee2","_x2","getAugustusSwapper","_ref4","_context3","AugustusSwapper","_callee3","_x3","getAugustusRFQ","_ref5","_context4","AugustusRFQ","_callee4","_x4","MinERC20Abi","constant","inputs","outputs","payable","stateMutability","approveTokenMethodFactory","contractCaller","amount","tokenAddress","overrides","spender","transactCall","address","abi","contractMethod","args","constructApproveToken","options","approveToken","approveTokenBulk","tokenAddresses","all","constructToken","tokenProps","tokenType","_tokenProps$tokenType","mainConnector","_tokenProps$mainConne","connectors","connectorsInput","_tokenProps$connector","_tokenProps$network","rest","_excluded","_extends","NOT_FOUND_RESPONSE","constructGetBalances","tokensUrl","getBalances","userAddress","tokens","getBalance","tokenAddressOrSymbol","token","_x5","getAllowances","tokenAddressesLowercaseSet","allowances","Set","toLowerCase","has","_ref5$allowance","allowance","_x6","_x7","_x8","getAllowance","_ref6","balanceOrNotFound","_balanceOrNotFound$al","_x9","_x10","_x11","constructGetAdapters","getAdapters","query","normalizeRateOptions","_ref$options","restInput","_objectWithoutPropertiesLoose","excludePricingMethods","excludeContractMethods","includeContractMethods","partner","_options$partner","includeDEXS","excludeDEXS","excludePools","restOptions","_excluded2","_map","PricingMethod","constructGetRate","pricesUrl","getRate","srcToken","destToken","parsedOptions","search","priceRoute","getRateByRoute","route","_route","constructSwapTx","getSwapTxData","constructGetTokens","getTokens","ZERO_ADDRESS","baseFetchUrlGetterFactory","orderKind","orderURLpart","sanitizeOrderData","nonceAndMeta","expiry","makerAsset","takerAsset","maker","taker","makerAmount","takerAmount","constructBaseFetchUrlGetter","OrderNFT","buildOrderData","verifyingContract","_ref$nonce","nonce","_makerAssetAddress","_takerAssetAddress","makerAssetId","_ref$takerAssetId","takerAssetId","makerAssetType","takerAssetType","AugustusAddress","_ref$taker","BigInt","assetAddressToUint","types","domain","assetAddress","assetType","_makerAsset","_takerAsset","startsWith","constructBuildTx","transactionsURL","buildTx","params","_params$takeSurplus","side","AmountMismatchError","sanitizedParams","takeSurplus","fetchParams","SwapSide","SELL","areAmountsCorrect","queryParams","orders","order","sanitizedOrder","sanitizeNFTOrderData","sanitizeLimitOrderData","signature","permitMakerAsset","positiveSlippageToUser","slippage","BUY","destAmount","srcAmount","Order","takerInNonce","contractTaker","AppVersion","constructBuildLimitOrder","buildLimitOrder","buildLimitOrderParams","_options$version","_yield$getContracts","constructSignLimitOrder","signLimitOrder","typedData","typedDataOnly","signTypedDataCall","MinAugustusRFQAbi","internalType","constructCancelLimitOrder","cancelLimitOrder","orderHash","cancelLimitOrderBulk","orderHashes","components","constructFillOrderDirectly","fillOrderDirectly","constructGetLimitOrders","getBaseFetchURLByEntityType","getLimitOrders","userParams","baseFetchURL","userURL","offset","limit","hideSmallBalances","orderBy","getRequiredBalance","getLimitOrderByHash","constructPostLimitOrder","getBaseFetchURLByOrderType","postTypedOrder","limitOrderWithSignatureAndPermit","postLimitOrder","postP2POrder","constructApproveTokenForLimitOrder","approveMakerTokenForLimitOrder","approveTakerTokenForLimitOrder","constructGetLimitOrdersContract","getLimitOrdersContract","getTokenTransferProxy","constructBuildLimitOrderTx","buildSwapTx","getSwapAndLimitOrderRate","getLimitOrdersRate","_ref2$options","_options","_checkAndParseOrders","totalTakerAmount","takerAmountString","rateInput","checkAndParseOrders","ContractMethod","simpleBuy","buildLimitOrderTx","_checkAndParseOrders2","fillParams","buildSwapAndLimitOrderTx","_checkAndParseOrders3","destDecimals","reduce","accum","takerAssetsSet","add","makerAssetsSet","size","_orders$","constructBuildNFTOrder","buildNFTOrder","buildNFTOrderParams","constructSignNFTOrder","signNFTOrder","constructCancelNFTOrder","cancelNFTOrder","cancelNFTOrderBulk","constructGetNFTOrders","getNFTOrders","getNFTOrderByHash","constructPostNFTOrder","NFTOrderWithSignatureAndPermit","postNFTLimitOrder","postNFTP2POrder","constructGetNFTOrdersContract","getNFTOrdersContract","MinNFTAbi","constructApproveTokenForNFTOrder","approveERC20ForNFTOrder","approveNFTorNFTOrder","constructBuildNFTOrderTx","getSwapAndNFTOrderRate","getNFTOrdersRate","buildNFTOrderTx","buildSwapAndNFTOrderTx","uintToAssetAddress","assetUint","constructFetcher","axios","extra","headers","apiKey","t0","fetch","body","POSTheaders","apiHeaders","JSON","stringify","json","ok","statusText","fromEntries","config","constructContractCaller","account","providerOrSigner","ethersProviderOrSigner","Contract","EthersContract","staticCall","_contract$callStatic","block","gas","restOverrides","normalizedOverrides","blockTag","gasLimit","callStatic","callOverrides","signer","txOverrides","isEthersProviderWithSigner","isEthersSigner","getSigner","isTypedDataCapableSigner","_signTypedData","_isProvider","isEthersProvider","_isSigner","web3","_contract$methods","currentProvider","eth","_contract$methods2","from","_from","preparedCall","promiEvent","unpromiEvent","send","on","bind","once","provider","_typedData","isProviderWithSendMethod","EIP712Domain","primaryType","findPrimaryType","jsonrpc","baseTypeRegex","candidates","candidatesSet","candidate","typedDataFields","_type$match","baseType","match","constructPartialSDK","_config$apiURL","_config$version","funcs","sdkFuncs","sdkSlice","assign","sdk","constructSwapSDK","constructSubmitLimitOrder","prepareLimitOrder","orderData","orderWithSignature","submitLimitOrder","submitP2POrder","constructAllLimitOrdersHandlers","constructSubmitNFTOrder","prepareNFTOrder","submitNFTOrder","constructAllNFTOrdersHandlers","ParaSwap","_ref$chainId","web3Provider","ethersDeps","constructAxiosFetcher","constructFetchFetcher","constructEthersContractCaller","constructWeb3ContractCaller","handleAPIError","e","extractHashFromTxResponse","_extractHashFromTxResponse","txResponse","hash","_proto","setWeb3Provider","setEthersProvider","_getTokens","_getAdapters","_getRateByRoute","srcDecimals","_getRate","_context5","_callee5","_x12","_x13","_x14","_x15","_x16","_buildTx","partnerAddress","partnerFeeBps","receiver","permit","deadline","_context6","_callee6","_x17","_x18","_x19","_x20","_x21","_x22","_x23","_x24","_x25","_x26","_x27","_x28","_x29","_x30","_x31","_getTokenTransferProxy","_provider","_context7","_callee7","_x32","_getAllowances","_callee8","_context8","_x33","_x34","_getAllowance","_callee9","_context9","_x35","_x36","_approveTokenBulk","txResponses","_context10","_callee10","_x37","_x38","_x39","_x40","_approveToken","sendOptions","_context11","_callee11","_x41","_x42","_x43","_x44","_x45","getMarketNames","_getMarketNames","_callee12","_context12","_getBalance","_callee13","_context13","_x46","_x47","_getBalances","_context14","_callee14","_x48","ERC20","ERC1155","ERC721","swap","limitOrders","nftOrders","providerOptions","_options$apiURL2","_options$version2","_options$apiURL","DEFAULT_VERSION","_constructEthersContr","_transactCall","contractTx","constructSimpleContractCaller"],"mappings":"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"}